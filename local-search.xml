<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Hamster（上篇）</title>
    <link href="/2022/09/25/Hamster1/"/>
    <url>/2022/09/25/Hamster1/</url>
    
    <content type="html"><![CDATA[<p>已不知花了多长时间，测试了多少次，升级优化了多少次，终于，Hamster诞生了</p><a id="more"></a><p><a href="https://github.com/DDDDanny/Hamster">Hamster</a>是一个基于PO模型的移动端应用UI自动化测试框架。他是基于uiautomator2（服务Android端）和facebook-wda（服务IOS端）来搭建的。为了能够更好的进行元素定位以及解决一些无法定位的元素，我引用了图片识别以及OCR技术来辅助进行元素定位，因为有了它们的加入，Hamster已无所不能💪</p><h3 id="为什么要创造Hamster"><a href="#为什么要创造Hamster" class="headerlink" title="为什么要创造Hamster"></a>为什么要创造Hamster</h3><p>我入职的时候，团队在为微信小程序自动化而苦恼，刚开始团队使用的是Airtest进行小程序UI自动化测试，效果还行，但是慢慢的，由于微信小程序的调整以及Poco的升级，我们执行自动化测试异常（如：微信闪退，元素无法捕获等）的概率大大提升，最终导致无法继续。</p><p>算是临危受命，我来接手小程序UI自动化测试，接手后，我发现之前所写的代码存在很大的问题，于是，我就开始重构之前的代码，与此同时，我也在尝试新的框架来代替Airtest。</p><p>起初我准备用Appium，结果效果很差，接着我去各大论坛寻找解决办法，很遗憾，大家都说暂时无法解决，更有趣的是，Appium团队和微信小程序团队在互相甩锅，都不解决问题。。。</p><p>由于公司的限制，我无法使用MiniTest框架</p><p>之后我还在不停尝试，我打开了Appium和Airtest源码，我发现它们的底层用的都是UIAutomator和wda，之后我就去Github上去找相关资料，发现了uiautomator2框架，研究了一段时间，我决定在uiautomator2的基础上做二次封装，来写一个适合团队，适合项目的新框架</p><h3 id="创造Hamster"><a href="#创造Hamster" class="headerlink" title="创造Hamster"></a>创造Hamster</h3><p>我有了思路后，Hamster初版很快就完成了，由于之前重构过一次测试用例，在重构中，我特别留意了兼容性的问题，所以在新框架的搭建完成后，同时也运用在了项目的回归测试上。</p><p>但是好景不长，由于微信内核升级以及设备系统的升级，有一些关键元素无法定位了，通过ADB获取原始DOM树发现，元素没了。这是个头疼的问题， 那段时间不知道如何解决，想迂回解决都没法。在那之后，我尝试了很多方法，也和前端同事一起努力过，但是都没有解决。</p><p>有一天我无意中想到，我为什么不去借鉴Airtest图片识别的办法呢？于是，我开始研究Airtest是如何实现的，明白原理后，我开始自己动手写图片识别的功能，没用多久，Hamster也具备了图片识别功能。</p><p>在用过一段时间后，我发现，效果不是很好，图片识别总会有点误差，虽然在对比前，我会对图片进行降噪等处理，但还是没有达到我的要求。我就在思考，有没有什么办法能够提高精准度？于是我就想到了OCR技术（Optical Character Recognition，光学字符识别）</p><p>有了想法，我就开始找资料学习研究，等各项条件都具备了，我就开始写OCR功能的内容了，很快Hamster也具备了图片识别功能。</p><p>至此，Hamster无所不能。</p>]]></content>
    
    
    <categories>
      
      <category>自动化测试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Flask配置&amp;操作数据库</title>
    <link href="/2021/05/01/FlaskAndDB/"/>
    <url>/2021/05/01/FlaskAndDB/</url>
    
    <content type="html"><![CDATA[<p>这篇文章总结一下Flask通过SQLAlchemy进行数据库（MySQL）操作。</p><a id="more"></a><h3 id="安装Flask-SQLAlchemy-amp-PyMySQL"><a href="#安装Flask-SQLAlchemy-amp-PyMySQL" class="headerlink" title="安装Flask-SQLAlchemy &amp; PyMySQL"></a>安装Flask-SQLAlchemy &amp; PyMySQL</h3><p>首先先介绍下Flask-SQLAlchemy &amp; PyMySQL这两个库</p><ul><li>Flask-SQLAlchemy：它是一套Flask的ORM框架，ORM是<em>Object Relationship Mapping（模型关系映射）</em></li><li>PyMySQL：它是在 Python3.x 版本中用于连接 MySQL 服务器的一个库</li></ul><blockquote><p>使用ORM，可以让我们操作数据库跟操作对象是一样的，一个表就是抽象成的一个类，一条数据就是抽象成的该类的一个对象。</p></blockquote><p>安装它们就和安装Python其他第三方库一样：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 安装Flask-SQLAlchemy</span>pip <span class="token function">install</span> flask-sqlalchemy<span class="token comment"># 安装PyMySQL</span>pip <span class="token function">install</span> pymysql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>安装完成后，我们就可以对MySQL进行配置啦👏</p><h3 id="Flask配置MySQL数据库"><a href="#Flask配置MySQL数据库" class="headerlink" title="Flask配置MySQL数据库"></a>Flask配置MySQL数据库</h3><p>无论你是用基础的Flask应用还是使用Flask的工厂应用，配置信息都是一样的。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 实例化Flask</span>app <span class="token operator">=</span> Flask<span class="token punctuation">(</span>__name__<span class="token punctuation">)</span><span class="token comment"># 配置数据库信息</span><span class="token comment"># 例如：app.config['SQLALCHEMY_DATABASE_URI'] = 'mysql+pymysql://root:123456.@127.0.0.1:3306/demo_db'</span>app<span class="token punctuation">.</span>config<span class="token punctuation">[</span><span class="token string">'SQLALCHEMY_DATABASE_URI'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'mysql+pymysql://数据库用户名:密码.@数据库地址:数据库端口/数据库名称'</span><span class="token comment"># 实例化SQLAlchemy</span>db <span class="token operator">=</span> SQLAlchemy<span class="token punctuation">(</span>app<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实例化SQLAlchemy后，就可以开始进行数据库的各种操作啦👏</p><h3 id="常用的SQLAlchemy字段类型"><a href="#常用的SQLAlchemy字段类型" class="headerlink" title="常用的SQLAlchemy字段类型"></a>常用的SQLAlchemy字段类型</h3><table><thead><tr><th>类型名</th><th>python中类型</th><th>说明</th></tr></thead><tbody><tr><td>Integer</td><td>int</td><td>常规整数，一般是32位</td></tr><tr><td>SmallInteger</td><td>int</td><td>短整型，一般是16位</td></tr><tr><td>BigInteger</td><td>int或long</td><td>不限制精度的整型</td></tr><tr><td>Float</td><td>float</td><td>浮点数</td></tr><tr><td>String</td><td>str</td><td>可变长字符串</td></tr><tr><td>Text</td><td>str</td><td>可变长字符串，适合大量文本</td></tr><tr><td>Unicode</td><td>unicode</td><td>可变长Unicode字符串</td></tr><tr><td>UnicodeText</td><td>unicode</td><td>可变长Unicode字符串，适合大量文本</td></tr><tr><td>Boolean</td><td>bool</td><td>布尔值</td></tr><tr><td>Date</td><td>datetime.date</td><td>日期类型</td></tr><tr><td>Time</td><td>datetime.time</td><td>时间类型</td></tr><tr><td>DateTime</td><td>datetime.datetime</td><td>日期和时间</td></tr><tr><td>Interva</td><td>datetime.timedelta</td><td>时间间隔</td></tr><tr><td>LargeBinary</td><td>str</td><td>二进制文件</td></tr></tbody></table><h3 id="常用的SQLAlchemy可选参数"><a href="#常用的SQLAlchemy可选参数" class="headerlink" title="常用的SQLAlchemy可选参数"></a>常用的SQLAlchemy可选参数</h3><table><thead><tr><th>可选参数</th><th>说明</th></tr></thead><tbody><tr><td>primary_key</td><td>如果为True，代表表的主键</td></tr><tr><td>unique</td><td>如果为True，代表这列不允许出现重复的值</td></tr><tr><td>index</td><td>如果为True，为这列创建索引，提高查询效率</td></tr><tr><td>nullable</td><td>如果为True，允许有空值，如果为False，不允许有空值</td></tr><tr><td>default</td><td>为这列定义默认值</td></tr></tbody></table><h3 id="常用的SQLAlchemy查询过滤器"><a href="#常用的SQLAlchemy查询过滤器" class="headerlink" title="常用的SQLAlchemy查询过滤器"></a>常用的SQLAlchemy查询过滤器</h3><table><thead><tr><th>过滤器</th><th>说明</th></tr></thead><tbody><tr><td>filter()</td><td>返回符合该条件的查询集，BaseQuery对象</td></tr><tr><td>filter_by()</td><td>返回符合该等值条件的查询集</td></tr><tr><td>limit</td><td>使用指定的值限定原查询返回的结果</td></tr><tr><td>offset()</td><td>偏移原查询返回的结果，返回一个新查询集</td></tr><tr><td>order_by()</td><td>根据字段进行排序，默认是正序，返回新查询集,desc可以反序</td></tr><tr><td>group_by()</td><td>根据字段进行分组，返回新查询集合</td></tr></tbody></table><h3 id="常用的SQLAlchemy查询执行器"><a href="#常用的SQLAlchemy查询执行器" class="headerlink" title="常用的SQLAlchemy查询执行器"></a>常用的SQLAlchemy查询执行器</h3><table><thead><tr><th>执行器</th><th>说明</th></tr></thead><tbody><tr><td>all()</td><td>以列表形式返回查询的所有结果</td></tr><tr><td>first()</td><td>返回查询的第一个结果，如果未查到，返回None</td></tr><tr><td>first_or_404()</td><td>返回查询的第一个结果，如果未查到，返回404</td></tr><tr><td>get()</td><td>返回指定主键对应的行，如不存在，返回None</td></tr><tr><td>get_or_404()</td><td>返回指定主键对应的行，如不存在，返回404</td></tr><tr><td>count()</td><td>返回查询结果的数量</td></tr><tr><td>paginate()</td><td>返回一个Paginate对象，它包含指定范围内的结果<br />参数一：第几页，参数二：每页个数，参数3：如果没有该页数返回False</td></tr></tbody></table><h3 id="Flask-SQLAlchemy对数据的增、删、改、查"><a href="#Flask-SQLAlchemy对数据的增、删、改、查" class="headerlink" title="Flask-SQLAlchemy对数据的增、删、改、查"></a>Flask-SQLAlchemy对数据的增、删、改、查</h3><h4 id="增加"><a href="#增加" class="headerlink" title="增加"></a>增加</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 实例化数据对象</span>data_demo <span class="token operator">=</span> DemoModel<span class="token punctuation">(</span>field1<span class="token operator">=</span><span class="token string">'1'</span><span class="token punctuation">)</span>db<span class="token punctuation">.</span>session<span class="token punctuation">.</span>add<span class="token punctuation">(</span>data_demo<span class="token punctuation">)</span>db<span class="token punctuation">.</span>session<span class="token punctuation">.</span>commit<span class="token punctuation">(</span><span class="token punctuation">)</span>db<span class="token punctuation">.</span>session<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 找到需要删除的数据</span>data_demo <span class="token operator">=</span> DemoModel<span class="token punctuation">.</span>query<span class="token punctuation">.</span>filter_by<span class="token punctuation">(</span>field<span class="token operator">=</span><span class="token string">'1'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>first<span class="token punctuation">(</span><span class="token punctuation">)</span>db<span class="token punctuation">.</span>session<span class="token punctuation">.</span>delete<span class="token punctuation">(</span>data_demo<span class="token punctuation">)</span>db<span class="token punctuation">.</span>session<span class="token punctuation">.</span>commit<span class="token punctuation">(</span><span class="token punctuation">)</span>db<span class="token punctuation">.</span>session<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 找到需要修改的数据</span>data_demo <span class="token operator">=</span> DemoModel<span class="token punctuation">.</span>query<span class="token punctuation">.</span>filter_by<span class="token punctuation">(</span>field<span class="token operator">=</span><span class="token string">'1'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>first<span class="token punctuation">(</span><span class="token punctuation">)</span>data_demo<span class="token punctuation">.</span>field <span class="token operator">=</span> <span class="token string">'2'</span>db<span class="token punctuation">.</span>session<span class="token punctuation">.</span>commit<span class="token punctuation">(</span><span class="token punctuation">)</span>db<span class="token punctuation">.</span>session<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 查询数据-全部查询，返回的list</span>data_list <span class="token operator">=</span> DemoModel<span class="token punctuation">.</span>query<span class="token punctuation">.</span><span class="token builtin">all</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment"># 增加过滤器进行查询</span>data_list <span class="token operator">=</span> DemoModel<span class="token punctuation">.</span>query<span class="token punctuation">.</span>filter_by<span class="token punctuation">(</span>field<span class="token operator">=</span><span class="token string">'1'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">all</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment"># 查询数据-返回查询结果中的第一条</span>data_demo <span class="token operator">=</span> DemoModel<span class="token punctuation">.</span>query<span class="token punctuation">.</span>first<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment"># 查询数据-返回指定主键对应的行</span>data_demo <span class="token operator">=</span> DemoModel<span class="token punctuation">.</span>query<span class="token punctuation">.</span>get<span class="token punctuation">(</span>primaryKey<span class="token punctuation">)</span><span class="token comment"># 通过执行SQL语句进行查询</span>sql <span class="token operator">=</span> <span class="token string">'select field from demo_model'</span>data_demo <span class="token operator">=</span> db<span class="token punctuation">.</span>session<span class="token punctuation">.</span>execute<span class="token punctuation">(</span>sql<span class="token punctuation">)</span><span class="token comment"># 查询需要的字段</span>data_demo <span class="token operator">=</span> db<span class="token punctuation">.</span>session<span class="token punctuation">.</span>query<span class="token punctuation">(</span>DemoModel<span class="token punctuation">.</span>name<span class="token punctuation">,</span> DemoModel<span class="token punctuation">.</span>age<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="连表"><a href="#连表" class="headerlink" title="连表"></a>连表</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 连接表</span>data_demo <span class="token operator">=</span> db<span class="token punctuation">.</span>session<span class="token punctuation">.</span>query<span class="token punctuation">(</span>  DemoModel<span class="token punctuation">.</span>name<span class="token punctuation">,</span> Demo2Mode<span class="token punctuation">.</span>book<span class="token punctuation">)</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>  Demo2Model<span class="token punctuation">,</span> Demo2Model<span class="token punctuation">.</span>user_id <span class="token operator">==</span> DemoModel<span class="token punctuation">.</span>user_id<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Flask操作数据库示例"><a href="#Flask操作数据库示例" class="headerlink" title="Flask操作数据库示例"></a>Flask操作数据库示例</h3><p><strong>DemoModel.py</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># DemoModel</span><span class="token keyword">class</span> <span class="token class-name">DemoModel</span><span class="token punctuation">(</span>db<span class="token punctuation">.</span>Model<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># 定义表名</span>    __tablename__ <span class="token operator">=</span> <span class="token string">'demo'</span>    <span class="token comment"># 主键必须要加 unique=True，否则会报错</span>    demo_id <span class="token operator">=</span> db<span class="token punctuation">.</span>Column<span class="token punctuation">(</span>db<span class="token punctuation">.</span>String<span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">,</span> primary_key<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span> unique<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>    demo_name <span class="token operator">=</span> db<span class="token punctuation">.</span>Column<span class="token punctuation">(</span>db<span class="token punctuation">.</span>String<span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">,</span> unique<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span> nullable<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span>    desc <span class="token operator">=</span> db<span class="token punctuation">.</span>Column<span class="token punctuation">(</span>db<span class="token punctuation">.</span>String<span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nullable<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span>    create_time <span class="token operator">=</span> db<span class="token punctuation">.</span>Column<span class="token punctuation">(</span>db<span class="token punctuation">.</span>Date<span class="token punctuation">,</span> default<span class="token operator">=</span>datetime<span class="token punctuation">.</span>now<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>DemoVeiw.py</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> DemoModel <span class="token keyword">import</span> DemoModel<span class="token keyword">class</span> <span class="token class-name">DemoView</span><span class="token punctuation">(</span><span class="token builtin">object</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">pass</span>        <span class="token comment"># 生成UUID</span>    <span class="token decorator annotation punctuation">@staticmethod</span>    <span class="token keyword">def</span> <span class="token function">__create_uuid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token builtin">str</span><span class="token punctuation">(</span>uuid<span class="token punctuation">.</span>uuid4<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment"># 序列化demo信息</span>    <span class="token keyword">def</span> <span class="token function">__demo_info_serializer</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> demo_item<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token punctuation">&#123;</span>            <span class="token string">'demoID'</span><span class="token punctuation">:</span> demo_item<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>            <span class="token string">'demoName'</span><span class="token punctuation">:</span> demo_item<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>            <span class="token string">'desc'</span><span class="token punctuation">:</span> demo_item<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span>            <span class="token string">'createTime'</span><span class="token punctuation">:</span> demo_item<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span>        <span class="token punctuation">&#125;</span>    <span class="token comment"># 获取demo列表</span>    <span class="token keyword">def</span> <span class="token function">get_demo_list</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>      <span class="token comment"># 执行SQL语句进行查询</span>        sql <span class="token operator">=</span> <span class="token triple-quoted-string string">''' select demo_id, demo_name, desc, create_time, from demo order by create_time desc; '''</span>        data_obj <span class="token operator">=</span> db<span class="token punctuation">.</span>session<span class="token punctuation">.</span>execute<span class="token punctuation">(</span>sql<span class="token punctuation">)</span>        data <span class="token operator">=</span> <span class="token punctuation">[</span>self<span class="token punctuation">.</span>__demo_info_serializer<span class="token punctuation">(</span>item<span class="token punctuation">)</span> <span class="token keyword">for</span> item <span class="token keyword">in</span> data_obj<span class="token punctuation">]</span>        <span class="token keyword">return</span> data    <span class="token comment"># 新增demo信息</span>    <span class="token keyword">def</span> <span class="token function">add_demo_info</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> demo_name<span class="token punctuation">,</span> desc<span class="token punctuation">)</span><span class="token punctuation">:</span>        demo_id <span class="token operator">=</span> self<span class="token punctuation">.</span>__create_uuid<span class="token punctuation">(</span><span class="token punctuation">)</span>        demo_info <span class="token operator">=</span> DemoModel<span class="token punctuation">(</span>         demo_id<span class="token operator">=</span>demo_id<span class="token punctuation">,</span>          demo_name<span class="token operator">=</span>demo_name<span class="token punctuation">,</span>          desc<span class="token operator">=</span>desc        <span class="token punctuation">)</span>        db<span class="token punctuation">.</span>session<span class="token punctuation">.</span>add<span class="token punctuation">(</span>demo_info<span class="token punctuation">)</span>        db<span class="token punctuation">.</span>session<span class="token punctuation">.</span>commit<span class="token punctuation">(</span><span class="token punctuation">)</span>        db<span class="token punctuation">.</span>session<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment"># 删除demo信息</span>    <span class="token keyword">def</span> <span class="token function">del_demo_info</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> demo_id<span class="token punctuation">)</span><span class="token punctuation">:</span>        demo_info <span class="token operator">=</span> DemoModel<span class="token punctuation">.</span>query<span class="token punctuation">.</span>filter_by<span class="token punctuation">(</span>demo_id<span class="token operator">=</span>demo_id<span class="token punctuation">)</span><span class="token punctuation">.</span>first<span class="token punctuation">(</span><span class="token punctuation">)</span>        db<span class="token punctuation">.</span>session<span class="token punctuation">.</span>delete<span class="token punctuation">(</span>demo_info<span class="token punctuation">)</span>        db<span class="token punctuation">.</span>session<span class="token punctuation">.</span>commit<span class="token punctuation">(</span><span class="token punctuation">)</span>        db<span class="token punctuation">.</span>session<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>           <span class="token comment"># 编辑demo信息</span>    <span class="token keyword">def</span> <span class="token function">edit_demo_info</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> demo_id<span class="token punctuation">,</span> demo_name<span class="token punctuation">,</span> desc<span class="token punctuation">)</span><span class="token punctuation">:</span>        demo_info <span class="token operator">=</span> DemoModel<span class="token punctuation">.</span>query<span class="token punctuation">.</span>filter_by<span class="token punctuation">(</span>demo_id<span class="token operator">=</span>demo_id<span class="token punctuation">)</span><span class="token punctuation">.</span>first<span class="token punctuation">(</span><span class="token punctuation">)</span>        demo_info<span class="token punctuation">.</span>demo_name <span class="token operator">=</span> demo_name        demo_info<span class="token punctuation">.</span>desc <span class="token operator">=</span> desc        db<span class="token punctuation">.</span>session<span class="token punctuation">.</span>commit<span class="token punctuation">(</span><span class="token punctuation">)</span>        db<span class="token punctuation">.</span>session<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>这里写了一部分基础的数据库操作，如果想深入了解，可以去<a href="https://www.sqlalchemy.org/">SQLAlchemy</a> &amp; <a href="https://flask-sqlalchemy.palletsprojects.com/en/2.x/">Flask-SQLAlchemy</a>去了解</p>]]></content>
    
    
    <categories>
      
      <category>测试经验</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>浅谈精准测试</title>
    <link href="/2021/02/19/PreciseTesting/"/>
    <url>/2021/02/19/PreciseTesting/</url>
    
    <content type="html"><![CDATA[<p>最近对精准测试比较感兴趣，就去查了些资料，了解了一些有关精准测试的东西，这篇文章就来记录一下我个人的一些想法。</p><a id="more"></a><h3 id="什么是精准测试？"><a href="#什么是精准测试？" class="headerlink" title="什么是精准测试？"></a>什么是精准测试？</h3><p>首先呢，我们来看看来自百度的比较官方的说明：</p><blockquote><p>精准测试是一套计算机测试辅助分析系统。精准测试的核心组件包含的软件测试示波器、用例和代码的双向追溯、智能回归测试用例选取、覆盖率分析、缺陷定位、测试用例聚类分析、测试用例自动生成系统，这些功能完整的构成了精准测试技术体系。</p></blockquote><p>我所理解的精准测试就是：</p><blockquote><p>能够提高测试效率的一种手段，一个过程，也是一个测试方法集。</p></blockquote><p>下面呢，我来说明一下：</p><ul><li><p>一种手段：</p><blockquote><p>我认为精准测试可以独立与黑盒和白盒测试之外，为什么呢？我觉得原因有两点：</p><ol><li>精准测试中有白盒测试的内容，但是不完全都是白盒测试；</li><li>精准测试要和黑盒测试配合使用，才能达到最好的效果；</li></ol></blockquote></li><li><p>一个过程：</p><blockquote><p>我认为想要真正意义上实现精准测试，绝非一朝一夕的事，而且绝不是一个人能够完成的。</p><p>它应该是一个由一个团队多方人员共同协作，循序渐进，不断完善，不断优化，不断扩展，不断推动的一个过程。</p></blockquote></li><li><p>一个测试方法集：</p><blockquote><p>我认为精准测试包含了多个测试方法：静态代码走读、代码差异分析、代码覆盖率统计及分析、调用链路分析、用例精准筛选等</p></blockquote></li></ul><h3 id="为什么要做精准测试？"><a href="#为什么要做精准测试？" class="headerlink" title="为什么要做精准测试？"></a>为什么要做精准测试？</h3><p>这个问题简单的回答就是：<em>传统的测试技术已经满足不了现在的产品高质量要求了</em></p><p>精准测试的出现一定是有了需要它的需求，做测试的小伙伴们，一定也遇到过这样的问题：</p><ul><li>测试过程完全按照测试用例执行，但是上线后还是会有问题，这时测试同学就会有个<code>测试遗漏</code>的锅</li><li>系统越做越大，逻辑越来越复杂，一个迭代后，回归测试的量也越来越大，执行起来非常困难，而且实际上执行了很多不必要的测试用例</li><li>当开发说只改了一个方法，那么这个方法所涉及到的应用层接口有多少？这个是需要和开发进行确认的，即使确认后，也容易风险失控，毕竟是人为控制的</li></ul><p>通过以上3个点，也就能说明精准测试的必要性了：</p><ul><li>功能测试执行完毕后，代码覆盖率大约能到达70%，由精准测试中的代码覆盖率监控、统计及分析，来补足剩下的30%</li><li>通过精准测试中的代码走读和差异分析，判断代码修改的范围，然后进行调用链路分析，就能解决最后两个问题</li><li>通过调用链路分析，可以实现用例精准筛选并且执行测试用例</li></ul><h3 id="说说现实中的精准测试"><a href="#说说现实中的精准测试" class="headerlink" title="说说现实中的精准测试"></a>说说现实中的精准测试</h3><ul><li>精准测试需要黑盒、白盒测试的配合才能够发挥出最大的效能。白盒、黑盒测试作为<code>基础</code>，精准测试作为<code>扩展</code></li><li>想要真正意义上的完成精准测试，对于大部分公司来说，还是有些困难，毕竟对人员和团队的要求比较高</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>我认为，精准测试是目前大多数产品突破质量瓶颈的重要手段之一，所以我希望在未来能够将精准测试做的更好，并且普及到整个测试圈，这也能够提升测试的技能水平，让测试更加有话语权，让测试为开发、为项目做更多的事！</p>]]></content>
    
    
    <categories>
      
      <category>测试技术</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>什么是软件测试？</title>
    <link href="/2020/11/20/SoftwareTesting/"/>
    <url>/2020/11/20/SoftwareTesting/</url>
    
    <content type="html"><![CDATA[<p>这篇文章来说说我所理解的软件测试吧！🙈</p><a id="more"></a><h3 id="什么是测试"><a href="#什么是测试" class="headerlink" title="什么是测试"></a>什么是测试</h3><p>在说软件测试前，我想先说下什么是测试。下面👇是百度百科给的解释：</p><blockquote><p>测试是具有试验性质的测量，即测量和试验的综合。</p></blockquote><p>我认为，测试是一个根据<code>标准</code>检验对象的<code>过程</code>，这里的对象就比较广泛了，硬件测试、软件测试、心理测试、体能测试、智力测试等等很多种测试类型，而这次只是说说软件测试。</p><h3 id="软件测试的定义"><a href="#软件测试的定义" class="headerlink" title="软件测试的定义"></a>软件测试的定义</h3><p>下面👇是比较官方的说法：</p><blockquote><p>软件测试（英语：Software Testing），描述一种用来促进鉴定软件的正确性、完整性、安全性和质量的过程。换句话说，软件测试是一种实际输出与预期输出之间的审核或者比较过程。软件测试的经典定义是：在规定的条件下对程序进行操作，以发现程序错误，衡量软件质量，并对其是否能满足设计要求进行评估的过程。</p></blockquote><p>实际上面👆说了3种定义，但是我认为可以再简单一点：</p><blockquote><p>软件测试就是验证软件产品是否与设计需求一致的过程</p></blockquote><p>它满足了测试的定义：有标准，是个过程</p><p>测试圈有这么一种说法：<code>需求上写的越少，测试的工作就越多</code>😅</p><p>这句话也可以用在我对软件测试的定义上，怎么说呢，定义说的很简单，但其实是很复杂的一个过程。想要做好软件测试，是需要很多经验、理论和技能支撑的。</p><h3 id="软件测试的分类"><a href="#软件测试的分类" class="headerlink" title="软件测试的分类"></a>软件测试的分类</h3><p>软件测试根据不同条件，有不同的分类：</p><ul><li><p>按照软件载体划分：</p><blockquote><p>PC客户端测试、PCWeb端测试、移动端App测试、小程序测试</p></blockquote></li><li><p>按阶段划分：</p><blockquote><p>单元测试、集成测试、系统测试、验收测试、回归测试、冒烟测试</p></blockquote></li><li><p>按是否查看代码：</p><blockquote><p>黑盒测试、白盒测试、灰盒测试</p></blockquote></li><li><p>按测试实施组织划分：</p><blockquote><p>α测试、β测试、第三方测试</p></blockquote></li><li><p>按照执行方式划分：</p><blockquote><p>手工测试、自动化测试、静态测试、动态测试</p></blockquote></li><li><p>按测试目的划分：</p><blockquote><p>功能测试、性能测试、安全性测试、兼容性测试、UI测试、易用性测试、业务逻辑测试、安装卸载测试、压力测试、可用性测试等</p></blockquote></li><li><p>按测试地域划分：</p><blockquote><p>本地化测试、国际化测试</p></blockquote></li></ul><p>以上👆就是总结的一些主要的测试分类，每一种测试都有它测试的要点，虽然我们在工作中不会遇到这里所有的测试，但是我们还是需要知道：<code>他们都是在干什么，做这种类型的测试它的要点是什么</code>。</p><p>其实我觉得分类可以再简单一点，可以直接分成：功能测试和非功能测试，而其他的测试活动都是建立在他们之上的，他们可以作为基础，向下继续划分。</p><h3 id="软件测试的天花板"><a href="#软件测试的天花板" class="headerlink" title="软件测试的天花板"></a>软件测试的天花板</h3><p>最后我来说说软件测试的天花板，我认为软件测试是有3个阶段的：</p><ol><li>功能测试阶段（就是使用鼠标点点点，会使用一些工具进行辅助测试）</li><li>自动化测试阶段（点点点变少了，更多的是去写一些自动化测试脚本，配合功能测试人员进行测试）</li><li>测试开发阶段（写测试工具、测试框架和测试平台来帮助功能测试人员和自动化测试人员完成测试任务）</li></ol><p>软件测试有3个阶段，我认为天花板就只有两个：</p><ul><li><p>功能测试到自动化测试的天花板</p><p>这个天花板我认为是最难突破的一个天花板。为什么是最难的呢？原因有两点：</p><blockquote><ol><li>因为第一个阶段是很枯燥乏味又漫长的，一部分人坚持不下来就转行了，一部分人坚持下来了但是已经没有了激情和欲望，一部分人坚持下来了，也有突破的激情和欲望，但是对技术缺乏了天赋，这三部分人都是很难突破的；</li><li>想要突破这个天花板，不仅需要技术过关，还需要大量测试经验的支撑</li></ol></blockquote><p>这就是我为什么认为这个天花板是最难突破的。</p></li><li><p>自动化测试到测试开发的天花板</p><p>这个天花板呢，虽说没有第一个难，但是也是有难度的：</p><blockquote><ol><li>对软件测试有深刻的理解，熟练掌握测试技术，有大量的代码基础，在技术方面有一定的广度，无论是前端、后端、数据库还是服务器，都要了解</li><li>要有软件工程的思想，熟练使用掌握的各种技能，快速解决研发团队的问题，确保测试左移和右移都能够正常进行</li></ol></blockquote></li></ul><p>两个天花板都已经简单说了下，但是作为一个优秀的测试人员，不一定非要突破这个天花板，因为对于测试人员来说，最最重要的是<code>业务</code>，当你业务非常非常熟悉时，即使你在第一阶段，也是非常NB的！所以我觉得，测试人员想突破天花板，突破自我，是没有问题的，但是认清自己到底适合什么，到底想要什么才是最重要的。</p>]]></content>
    
    
    <categories>
      
      <category>测试经验</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Nginx学习笔记（二）</title>
    <link href="/2020/10/15/NginxNote2/"/>
    <url>/2020/10/15/NginxNote2/</url>
    
    <content type="html"><![CDATA[<p>在上一篇文章说了我对Nginx理解，这篇文章就来说说Nginx的在Linux下的安装和基础的配置。</p><a id="more"></a><h3 id="Nginx安装"><a href="#Nginx安装" class="headerlink" title="Nginx安装"></a>Nginx安装</h3><p>我这里写下Linux下的安装过程。</p><h4 id="Linux（Centos7）"><a href="#Linux（Centos7）" class="headerlink" title="Linux（Centos7）"></a>Linux（Centos7）</h4><h4 id="1-安装依赖包"><a href="#1-安装依赖包" class="headerlink" title="1. 安装依赖包"></a>1. 安装依赖包</h4><pre class="line-numbers language-basic" data-language="basic"><code class="language-basic"><span class="token operator">/</span><span class="token operator">/</span> 一键安装依赖包yum <span class="token operator">-</span>y install gcc zlib zlib<span class="token operator">-</span>devel pcre<span class="token operator">-</span>devel openssl openssl<span class="token operator">-</span>devel<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="2-下载并解压后安装包"><a href="#2-下载并解压后安装包" class="headerlink" title="2. 下载并解压后安装包"></a>2. 下载并解压后安装包</h4><pre class="line-numbers language-basic" data-language="basic"><code class="language-basic">cd <span class="token operator">/</span>usr<span class="token operator">/</span>local<span class="token operator">/</span><span class="token operator">/</span> 创建文件夹<span class="token keyword">mkdir</span> nginx<span class="token operator">/</span><span class="token operator">/</span> 下载安装包<span class="token punctuation">(</span>具体版本根据自己需求<span class="token punctuation">)</span>wget http<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>nginx.org<span class="token operator">/</span>download<span class="token operator">/</span>nginx<span class="token operator">-</span>xx.xx.xx.tar.gz<span class="token operator">/</span><span class="token operator">/</span> 解压tar <span class="token operator">-</span>xvf nginx<span class="token operator">-</span>xx.xx.xx.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-安装Nginx"><a href="#3-安装Nginx" class="headerlink" title="3. 安装Nginx"></a>3. 安装Nginx</h4><pre class="line-numbers language-basic" data-language="basic"><code class="language-basic"><span class="token operator">/</span><span class="token operator">/</span> 进入Nginx目录cd <span class="token operator">/</span>usr<span class="token operator">/</span>local<span class="token operator">/</span>nginx<span class="token operator">/</span>nginx<span class="token operator">-</span>xx.xx.xx<span class="token operator">/</span><span class="token operator">/</span> 执行.<span class="token operator">/</span>configure <span class="token operator">-</span><span class="token operator">-</span>prefix<span class="token operator">=</span><span class="token operator">/</span>usr<span class="token operator">/</span>local<span class="token operator">/</span>nginx <span class="token operator">-</span><span class="token operator">-</span><span class="token function">with</span><span class="token operator">-</span>http_stub_status_module <span class="token operator">-</span><span class="token operator">-</span><span class="token function">with</span><span class="token operator">-</span>http_ssl_module<span class="token operator">/</span><span class="token operator">/</span> 执行make命令make<span class="token operator">/</span><span class="token operator">/</span> 执行make install命令make install<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-启动Nginx"><a href="#4-启动Nginx" class="headerlink" title="4. 启动Nginx"></a>4. 启动Nginx</h4><pre class="line-numbers language-basic" data-language="basic"><code class="language-basic"><span class="token operator">/</span><span class="token operator">/</span> 进入nginx启动目录cd <span class="token operator">/</span>usr<span class="token operator">/</span>local<span class="token operator">/</span>nginx<span class="token operator">/</span>sbin<span class="token operator">/</span><span class="token operator">/</span> 运行nginx.<span class="token operator">/</span>nginx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="5-将Nginx添加到全局变量中"><a href="#5-将Nginx添加到全局变量中" class="headerlink" title="5. 将Nginx添加到全局变量中"></a>5. 将Nginx添加到全局变量中</h4><p>添加到全局变量中后，就可以在任何地方使用Nginx命令啦</p><pre class="line-numbers language-basic" data-language="basic"><code class="language-basic">ln <span class="token operator">-</span>s 你的nginx的位置 <span class="token operator">/</span>usr<span class="token operator">/</span>local<span class="token operator">/</span>bin<span class="token operator">/</span><span class="token operator">/</span><span class="token operator">/</span>ln –s 源文件 目标文件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="6-Nginx常用命令"><a href="#6-Nginx常用命令" class="headerlink" title="6. Nginx常用命令"></a>6. Nginx常用命令</h4><pre class="line-numbers language-basic" data-language="basic"><code class="language-basic"><span class="token operator">/</span><span class="token operator">/</span> 启动nginx<span class="token operator">/</span><span class="token operator">/</span> 关闭nginx <span class="token operator">-</span>s <span class="token keyword">stop</span><span class="token operator">/</span><span class="token operator">/</span> 重载配置文件nginx <span class="token operator">-</span>s reload<span class="token operator">/</span><span class="token operator">/</span> 检查nginx语法，建议每次在重载前检查nginx <span class="token operator">-</span>t<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总的来说，安装还是蛮简单的。</p><h3 id="配置Nginx"><a href="#配置Nginx" class="headerlink" title="配置Nginx"></a>配置Nginx</h3><h4 id="静态服务器配置"><a href="#静态服务器配置" class="headerlink" title="静态服务器配置"></a>静态服务器配置</h4><pre class="line-numbers language-nginx" data-language="nginx"><code class="language-nginx"><span class="token keyword">server</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">listen</span> <span class="token number">80</span><span class="token punctuation">;</span>     <span class="token keyword">server_name</span>  localhost<span class="token punctuation">;</span>      <span class="token keyword">client_max_body_size</span> <span class="token number">1024</span>M<span class="token punctuation">;</span>  <span class="token comment"># 控制请求内容大小</span>      <span class="token keyword">location</span> <span class="token operator">/</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">root</span>   xxxxx<span class="token punctuation">;</span>  <span class="token comment"># 静态文件地址   </span>   <span class="token keyword">index</span>  <span class="token keyword">index</span><span class="token punctuation">.</span>html<span class="token punctuation">;</span>  <span class="token comment"># 静态文件类型</span>  <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="反向代理配置"><a href="#反向代理配置" class="headerlink" title="反向代理配置"></a>反向代理配置</h4><pre class="line-numbers language-nginx" data-language="nginx"><code class="language-nginx"><span class="token keyword">server</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">listen</span>     <span class="token number">80</span><span class="token punctuation">;</span>                                                           <span class="token keyword">server_name</span>  访问地址<span class="token operator">/</span>域名<span class="token punctuation">;</span>  <span class="token keyword">client_max_body_size</span> <span class="token number">1024</span>M<span class="token punctuation">;</span>  <span class="token comment"># 控制请求内容大小</span>  <span class="token keyword">location</span> <span class="token operator">/</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">proxy_pass</span> 代理地址及端口<span class="token punctuation">;</span>    <span class="token keyword">proxy_set_header</span> Host <span class="token variable">$host</span><span class="token punctuation">:</span><span class="token variable">$server_port</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这是我第一次进行Nginx的实践，只是对其进行了初步的了解和使用，如果有写的不对或写的不好的地方，请见谅。</p>]]></content>
    
    
    <categories>
      
      <category>测试工具</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Nginx学习笔记（一）</title>
    <link href="/2020/10/05/NginxNote1/"/>
    <url>/2020/10/05/NginxNote1/</url>
    
    <content type="html"><![CDATA[<p>最近我在部署我自己项目的时候，使用到了Nginx，之前一直只是了解过一点点，而没有实际使用过，这次呢，我就边学习边使用，完成自己项目的部署，并且对Nginx有了一定的了解。</p><a id="more"></a><h3 id="Nginx能做什么"><a href="#Nginx能做什么" class="headerlink" title="Nginx能做什么"></a>Nginx能做什么</h3><p>Nginx可以做<code>正向代理</code>、<code>反向代理</code>和<code>实现负载均衡</code>，这里我会结合生活上买车的例子，来解释这三个东东。</p><h4 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h4><p>举个例子👀：</p><p>我们去汽车店买车，汽车店就是一个代理，而生产车辆的工厂就是个被代理方。买现车的时候，你是知道这个车是哪个生产商出来的，而生产商是不知道你的信息的。这个过程就是<code>正向代理</code>。</p><p>简单来说，正向代理就是我们通过某种渠道，去做我们做不了的事，比如说FQ。</p><p>客户端必须设置正向代理服务器，需要知道正向代理服务器的地址还有代理端口。服务器只知道请求是从哪个代理发来的，而不知道请求是从哪个客户端发来的。</p><p>正向代理的用途：</p><ol><li>访问原本无法访问的网络资源：FaceBook、Google等等</li><li>可以做为资源缓存使用，加速访问速度</li></ol><h4 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h4><p>再举个例子👀：</p><p>还是买车，我们要定制一辆车，我们会把我们的信息和需求提给汽车店，汽车店把信息再给汽车生产商，最后生产出我们想要的车辆，这个过程我们是不知道哪个生产商做这件事，但是汽车生产商会知道我们的信息和需求，在做定制服务。这个过程就是<code>反向代理</code>。</p><p>对于反向代理，请求的来源是明确的，但是请求具体交给谁处理，客户端并不知道。</p><p>反向代理的用途：</p><ol><li>保证内网安全（将反向代理作为公网访问地址）</li><li>实现负载均衡</li></ol><h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h4><p>接着上面的例子👀：</p><p>我们需求可能有很多，给一个汽车生产商来做是忙不过来的，那么需要分发给很多个生产商来做，用最短的时间完成这个定制的汽车，这个就是<code>负载均衡</code>。</p><p>在部署集群时，任务能够按照规则随机分发到指定的服务器上进行处理，这个也是Nginx反向代理的重要实践。</p>]]></content>
    
    
    <categories>
      
      <category>测试工具</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Jenkins实现持续集成自动化测试（三）</title>
    <link href="/2020/10/05/Jenkins3/"/>
    <url>/2020/10/05/Jenkins3/</url>
    
    <content type="html"><![CDATA[<p>上一篇文章写了Jenkins任务的配置以及流水线的基础配置，这篇文章我们就来说说Jenkins节点配置、权限以及数据备份👏</p><a id="more"></a><h3 id="设置运行节点（slave-agent）"><a href="#设置运行节点（slave-agent）" class="headerlink" title="设置运行节点（slave-agent）"></a>设置运行节点（slave-agent）</h3><h4 id="配置Windows节点"><a href="#配置Windows节点" class="headerlink" title="配置Windows节点"></a>配置Windows节点</h4><p><code>Windows节点主要用于执行UI自动化测试任务</code></p><p>新建节点后，直接下载agent.jar文件，我是在Windows下，写了一个bat文件，用来执行slaveAgent和主节点的连接。</p><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd"># 在节点详情中有显示&gt; java -jar agent.jar -jnlpUrl Jenkins地址&#x2F;computer&#x2F;TestNode&#x2F;slave-agent.jnlp -secret 密钥 -workDir &quot;节点的工作空间&quot; -internalDir &quot;项目的工作空间&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>配置从节点时，标签是在写Jenkinsfile时会用到的，其他的设置，根据需要设置即可。</p><blockquote><p>这里有个坑，Windows节点不稳定，时常会断开，这个是最坑的。虽说节点使用过程中，不会断开，但是空闲时，简直太容易断开了，所以我写了个Python脚本来保证它在掉线后，能够自动重连。</p></blockquote><h4 id="配置Linux节点"><a href="#配置Linux节点" class="headerlink" title="配置Linux节点"></a>配置Linux节点</h4><p><code>Linux节点主要用于执行前端的构建部署任务</code></p><p>配置Linux就简单多了，我选择使用ssh连接，配置好主机地址和凭证即可。</p><p><strong><em>这里说下，无论配置Windows还是Linux节点时，远程工作目录：使用该节点执行的任务数据，都会在这个目录下。那么有多个项目时，一定要在任务配置下，分好工作空间，避免数据污染。</em></strong></p><h3 id="Jenkins权限设置"><a href="#Jenkins权限设置" class="headerlink" title="Jenkins权限设置"></a>Jenkins权限设置</h3><p>​Jenkins权限我并没有使用Jenkins自带的安全矩阵，因为它并不满足我的需求，所以我选择了Role Based Strategy这个插件，它能够配置并分配角色，这样把权限管理变成角色管理，使得权限变得更加清晰。</p><h3 id="Jenkins数据备份"><a href="#Jenkins数据备份" class="headerlink" title="Jenkins数据备份"></a>Jenkins数据备份</h3><p>Jenkins备份我选择了ThinBackUp插件，用起来比较简单：</p><ol><li>设置服务器中，存放备份文件的路径（Linux记得把文件夹权限打开）</li><li>设置定时时间，cron规则书写即可</li><li>设置备份哪些内容</li></ol><p>备份恢复直接选择备份的目录，直接恢复就好。</p><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>​这个文档记录了我最初的探索到最终的投入使用整个过程，Jenkins是一个蛮好的CICD工具，当然他也存在一些坑，不过整个过程中还是蛮有趣的。</p><p>我希望这篇文章能给读到文章的人，一点点🤏帮助</p>]]></content>
    
    
    <categories>
      
      <category>测试工具</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Jenkins实现持续集成自动化测试（二）</title>
    <link href="/2020/10/02/Jenkins2/"/>
    <url>/2020/10/02/Jenkins2/</url>
    
    <content type="html"><![CDATA[<p>上一篇文章写了Jenkins是什么以及它的安装与初始化，这篇文章我们就来说说任务的初始化以及流水线的配置吧👏</p><a id="more"></a><h3 id="任务初始化"><a href="#任务初始化" class="headerlink" title="任务初始化"></a>任务初始化</h3><h4 id="新建及配置任务"><a href="#新建及配置任务" class="headerlink" title="新建及配置任务"></a>新建及配置任务</h4><p>进入Jenkins就可以看到新建任务的按钮，点击后选择自由项目即可，流水线项目之后会说。创建完成后，即可配置Jenkins任务。</p><h5 id="常规配置"><a href="#常规配置" class="headerlink" title="常规配置"></a>常规配置</h5><p>常规配置，勾选自定义的工作空间，输入你在本地的项目目录</p><h5 id="源码管理"><a href="#源码管理" class="headerlink" title="源码管理"></a>源码管理</h5><p>如果是执行本地代码，这里就是默认设置：无</p><p>如果是执行远程代码，我用的是Coding，所以选择Git。添加凭证即可（用什么方式，自己选择即可）</p><h5 id="触发器设置"><a href="#触发器设置" class="headerlink" title="触发器设置"></a>触发器设置</h5><p>我配置的定时任务（其实就是轮询），定时任务构建规则我就不写了，点击输入框后的❓就可以看到说明</p><h5 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h5><p>因为我的UI自动化测试项目会在Windows下运行，我选择Cmd执行：</p><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">workon 虚拟环境名称&amp;&amp;python 代码入口文件  # 这是我使用virtualenv虚拟环境的写法python 代码入口文件  # 如果没有虚拟环境，就直接这么写就好<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>配置测试报告样式：</p><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">System.setProperty(&quot;hudson.model.DirectoryBrowserSupport.CSP&quot;, &quot;&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="构建后操作"><a href="#构建后操作" class="headerlink" title="构建后操作"></a>构建后操作</h5><p>选择添加：Pulish HTML_reports</p><p>需要注意⚠️：报告地址和报告名称不能错，因为Jenkins要把你生成的报告，复制到他自己的目录下，然后再做展示的。</p><h5 id="保存"><a href="#保存" class="headerlink" title="保存"></a>保存</h5><p>至此，Jenkins的执行UI自动化测试任务就配置好了。</p><h3 id="执行任务"><a href="#执行任务" class="headerlink" title="执行任务"></a>执行任务</h3><p>在Job List中点击需要执行的任务，进入任务详情，点击立即执行即可执行项目。</p><h3 id="配置流水线执行UI自动化测试任务"><a href="#配置流水线执行UI自动化测试任务" class="headerlink" title="配置流水线执行UI自动化测试任务"></a>配置流水线执行UI自动化测试任务</h3><h4 id="什么是流水线（Pipeline）？"><a href="#什么是流水线（Pipeline）？" class="headerlink" title="什么是流水线（Pipeline）？"></a>什么是流水线（Pipeline）？</h4><p>​Jenkins流水线是对Jenkins的进一步完善，使得执行自动化任务更加完整。既然是流水线，自然具备了阶段和步骤，执行期间更加清晰的看出执行的整个过程。</p><h3 id="新建并配置流水线任务"><a href="#新建并配置流水线任务" class="headerlink" title="新建并配置流水线任务"></a>新建并配置流水线任务</h3><p>创建任务时，选择流水线即可。</p><p>配置流水线任务相比自由任务简单一点，我这里只配置一下流水线，其他的东西，按照需要配置就好。</p><p>定义流水线有两个选择：</p><ul><li>Pipeline script from SCM （通过SCM（Source Coce Management）读取Jenkinsfile，实现流水线）</li><li>Pipeline script （完全通过脚本编写流水线）</li></ul><p>​以上两种方法都可以，我选择使用第一种。第二种直接写就完事了，第一种需要配置一下你的SCM信息，也没什么难度，下面说说Jenkinsfile：</p><p>流水线的语法，在配置页面有，我就不写了。</p><p>温馨提示：一定要多看下左侧菜单栏的内容，你写Jenkinsfile会变得简单些。</p><p>下面是我写的Jenkinsfile</p><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">pipeline &#123;    &#x2F;* insert Declarative Pipeline here *&#x2F;    agent &#123;        label &#39;节点名称&#39;    &#125;    stages &#123;        stage(&#39;阶段名称&#39;) &#123;            steps &#123;                echo &#39;步骤下做的事情&#39;            &#125;        &#125;        stage(&#39;Run TestCase&#39;) &#123;        &#x2F;* Run Part1 and Part2&amp;Part3 in parallel ：parallel用来执行并行任务  *&#x2F;            parallel &#123;                stage(&#39;Run Part1&#39;) &#123;                    steps &#123;                        echo &#39;执行内容&#39;                        bat &#39;workon 虚拟环境名称&amp;&amp;python 代码入口文件&#39;                    &#125;                &#125;                stage(&#39;Run Part2 &amp; Part3&#39;) &#123;                    stages &#123;                        stage(&#39;Run Part2&#39;) &#123;                            steps &#123;                                echo &#39;执行内容&#39;                                bat &#39;workon 虚拟环境名称&amp;&amp;python 代码入口文件&#39;                            &#125;                        &#125;                        stage(&#39;Run Part3&#39;) &#123;                            steps &#123;                                echo &#39;执行内容&#39;                                bat &#39;workon 虚拟环境名称&amp;&amp;python 代码入口文件&#39;                            &#125;                        &#125;                    &#125;                &#125;            &#125;        &#125;        stage(&#39;Archive&#39;) &#123;            steps &#123;                echo &#39;执行内容&#39;            &#125;        &#125;        stage(&#39;Complete&#39;) &#123;            steps &#123;                echo &#39;执行内容&#39;            &#125;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>配置好就和代码放在一起，SCM拉代码时，就会读这个文件，最终达到流水线的效果。</p>]]></content>
    
    
    <categories>
      
      <category>测试工具</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Jenkins实现持续集成自动化测试（一）</title>
    <link href="/2020/10/01/Jenkins1/"/>
    <url>/2020/10/01/Jenkins1/</url>
    
    <content type="html"><![CDATA[<p>今天我们就来学习一下Jenkins是什么，我用它做了些什么以及安装与初始化👏</p><a id="more"></a><h3 id="Jenkins是什么"><a href="#Jenkins是什么" class="headerlink" title="Jenkins是什么"></a>Jenkins是什么</h3><p>​Jenkins是一个基于Java开发的开源项目，是一个持续集成工具（看到Java开发的，就知道它会很吃内存，而且Jenkins确实有内存泄露的问题）</p><h3 id="用Jenkins做什么呢"><a href="#用Jenkins做什么呢" class="headerlink" title="用Jenkins做什么呢"></a>用Jenkins做什么呢</h3><p>使用Jenkins是为了完善自动化测试流程，来完成自动化测试持续集成持续构建。</p><p>目前通过Jenkins，已经实现了本地和远程仓库代码的定时运行，测试报告收集、展示以及通过邮件发送测试报告。</p><p>整个过程中，还是遇到很多坑，后面会慢慢说到的。</p><h3 id="下载安装Jenkins"><a href="#下载安装Jenkins" class="headerlink" title="下载安装Jenkins"></a>下载安装Jenkins</h3><h4 id="Windows版"><a href="#Windows版" class="headerlink" title="Windows版"></a>Windows版</h4><p>这个没啥难度，百度Jenkins，找到官网就行。官网对中文支持的还是比较好的，所以没啥好说的。下载个稳定版就OK。</p><p>Jenkins官网地址：<a href="https://jenkins.io/zh/">https://jenkins.io/zh/</a></p><p>下载解压完成后，是个jenkins.msi文件，直接傻瓜式下一步安装就行，安装过程很快。</p><p>在安装完成之后，他默认会以windows服务启动，这是没有问题的，但是对于UI自动化测试来说，这个地方是个坑的，如果按照windows服务的方式启动Jenkins，是无法调起Chrome浏览器的（其他浏览器我没尝试，但是Chrome是调不起来的），Jenkins会在后台他自己的VM中去运行UI自动化测试脚本，跑脚本也没有问题，只是Jenkins的VM分辨率是1024*768，这样会导致在运行过程中，部分元素是定位不到的，最终用例运行失败。所以要跑UI自动化，Jenkins就不能使用windows服务的方式进行启动，要用启动war包的方式进行启动。</p><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">&gt; jave -jar jenkins.war<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>为什么上面这个坑要写在这里呢？是因为这里还有个大坑！如果你使用windows服务的方式启动Jenkins并且初始化全部完成后，你再改用war包启动，所有的初始化配置、插件、项目都没有了！所有的都需要你重新搞。（别问，问就是遭过！）</p><h4 id="Linux版"><a href="#Linux版" class="headerlink" title="Linux版"></a>Linux版</h4><p>Linux下我用的Docker部署的Jenkins，为什么要用Docker呢？原因很简单，我不想去搞JDK。</p><pre class="line-numbers language-basic" data-language="basic"><code class="language-basic">$ docker <span class="token keyword">run</span> <span class="token operator">-</span>d <span class="token operator">-</span>p <span class="token number">8096</span><span class="token punctuation">:</span><span class="token number">8080</span> \<span class="token operator">-</span><span class="token operator">-</span><span class="token keyword">name</span> jenkins <span class="token operator">-</span>p <span class="token number">50000</span><span class="token punctuation">:</span><span class="token number">50000</span> \<span class="token operator">-</span>v <span class="token operator">/</span>root<span class="token operator">/</span>jenkins_home<span class="token punctuation">:</span><span class="token operator">/</span>var<span class="token operator">/</span>jenkins_home \<span class="token operator">-</span><span class="token operator">-</span>restart<span class="token operator">=</span>always <span class="token operator">-</span>e JAVA_OPTS<span class="token operator">=</span><span class="token operator">-</span>Duser.timezone<span class="token operator">=</span>Asia<span class="token operator">/</span>Shanghai \jenkins<span class="token operator">/</span>jenkins<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用Docker部署Jenkins还是非常方便的，如果有什么问题，销毁容器，重新来就好。上面👆的Docker命令我不多说，就说两个点：</p><ul><li><code>-v /root/jenkins_home:/var/jenkins_home</code>: jenkins_home映射出来，是为了方便初始化和进行一些配置及之后的备份</li><li><code>-e JAVA_OPTS=-Duser.timezone=Asia/Shanghai</code>: 一定要改时区，如果不改，会出来一些奇奇怪怪得问题</li></ul><h3 id="Jenkins初始化"><a href="#Jenkins初始化" class="headerlink" title="Jenkins初始化"></a>Jenkins初始化</h3><p>初始化过程其实很简单，稍微复杂的就是下载插件上，接下来我会说明一下初始化：</p><ol><li>输入密码。密码所在的位置，页面上都有写，我就不多说了，复制粘贴即可；</li><li>下载插件，什么都不要勾选，直接下一步跳过下载插件；</li><li>创建用户，这个也没什么好说的，填写完下一步；</li><li>先不用填写实例，直接继续初始化就OK了；</li></ol><p>​    重点说下下载插件，毕竟Jenkins不仅是基于Java还是一个基于插件的应用。下载插件是有一个坑的，因为Jenkins插件服务器是在国外，国内访问非常慢，还有很大可能性下载失败。于是我们就想到了使用镜像，的确国内是有，但是清华源的update-center.json中，所有的插件地址都还是指向的官网，所以根本没有什么效果。</p><p>这里，我们需要替换一下这些坑爹的地址。找到/jenkins_home/updates/default.json文件，编辑其内容：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">http:&#x2F;&#x2F;updates.jenkins-ci.org&#x2F;download&#x2F;plugins&#x2F;把上面👆这个地址替换成下面👇这个地址https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;jenkins&#x2F;plugins&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>最后记得，在插件管理页面，关闭对 <code>update-center.json</code>的安全检查，否则每次更新后，你都要修改一次！</p><p>接下来就要安装插件了：</p><blockquote><p>Git、Git Server、Git client plugin、</p><p>Groovy、HTML Publisher plugin、Selenium HTML report、</p><p>Simple Theme Plugin  </p><p>注意：选中插件后，点击直接安装就行，别点下载待重启后安装。</p><p>安装插件完成后，记得重启Jenkins</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>测试工具</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>你好👋 Docker（三）</title>
    <link href="/2020/09/20/HIDocker3/"/>
    <url>/2020/09/20/HIDocker3/</url>
    
    <content type="html"><![CDATA[<p>上一篇文章介绍了如何制作Docker镜像，总的来说还是蛮简单的。这篇文章就来说说Docker容器的备份与恢复。👀</p><a id="more"></a><h3 id="Docker容器备份与恢复"><a href="#Docker容器备份与恢复" class="headerlink" title="Docker容器备份与恢复"></a>Docker容器备份与恢复</h3><p>​无论你是想备份数据还是做容器迁移，都会用到Docker容器备份。</p><h4 id="Docker容器备份"><a href="#Docker容器备份" class="headerlink" title="Docker容器备份"></a>Docker容器备份</h4><ol><li><p>查看Docker中的容器信息（如果你很清楚，就可以忽略这一步）</p><pre class="line-numbers language-basic" data-language="basic"><code class="language-basic"><span class="token operator">></span> docker ps<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>创建容器快照，创建完成后，就可以在本地镜像库中查看</p><pre class="line-numbers language-basic" data-language="basic"><code class="language-basic"><span class="token operator">></span> docker commit <span class="token operator">-</span>p 容器名称｜ID 新的镜像名称<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><p>Docker备份镜像已经生成，这个备份可以压缩打包存在本地机器，也可以上传至DockerHub中，这里我使用的上传至DockerHub，因为想要做迁移时，就非常方便，当然只能访问内网的服务器，就只能使用打包本地的方法了。</p><ul><li><p>登录Docker（先去DockerHub注册）</p><pre class="line-numbers language-basic" data-language="basic"><code class="language-basic"><span class="token operator">></span> docker login<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>为备份的镜像打个Tag</p><pre class="line-numbers language-basic" data-language="basic"><code class="language-basic"><span class="token operator">></span> docker tag 镜像名称｜ID 用户名<span class="token operator">/</span>仓库名<span class="token punctuation">:</span>TagName<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>Push DockerHub（先在DockerHub中新建个仓库，push命令在DockerHub的仓库页面也会显示）</p><pre class="line-numbers language-basic" data-language="basic"><code class="language-basic"><span class="token operator">></span> docker push 用户名<span class="token operator">/</span>仓库名<span class="token punctuation">:</span>TagName<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>等待Push完成。。。</p></li></ul><h4 id="Docker容器恢复"><a href="#Docker容器恢复" class="headerlink" title="Docker容器恢复"></a>Docker容器恢复</h4><p>因为备份的Docker镜像在DockerHub上，所以在需要部署的服务器上，需要登录DockerHub，然后拉取镜像并且运行即可：</p><pre class="line-numbers language-basic" data-language="basic"><code class="language-basic"><span class="token operator">></span> docker pull 镜像名称<span class="token operator">></span> docker <span class="token keyword">run</span> <span class="token operator">-</span>d ... 镜像名称<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="Docker的应用"><a href="#Docker的应用" class="headerlink" title="Docker的应用"></a>Docker的应用</h3><p>​目前，我使用Docker部署过：<code>Jenkins</code>、<code>禅道</code>、<code>Selenium Gird</code>、<code>Prometheus</code>、<code>node-exporter</code>、<code>blackbox-exporter</code>、<code>Cadvisor</code>、<code>Grafana</code>、<code>UpSource</code>、<code>Redis</code></p><p>​整体来说，Docker还是很好用的，为我减少了很多麻烦，同时，它也存在一些问题，比如：应用更新的麻烦、对内存的控制、容器之间的通信以及容器与外界的通信等等。。。</p>]]></content>
    
    
    <categories>
      
      <category>测试工具</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>你好👋 Docker（二）</title>
    <link href="/2020/09/18/HIDocker2/"/>
    <url>/2020/09/18/HIDocker2/</url>
    
    <content type="html"><![CDATA[<p>上一篇文章介绍了Docker的基本概念和常用命令，这篇文章就来说说怎么制作Docker镜像。👀</p><a id="more"></a><h3 id="制作Docker镜像"><a href="#制作Docker镜像" class="headerlink" title="制作Docker镜像"></a>制作Docker镜像</h3><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>为了方便测试组同学们执行自动化测试和开发进行冒烟测试，我写了一个自动化测试-Jenkins执行器。这是一个很小的工具类项目，前端我使用的是Vue全家桶，后端我使用的是Flask。部署的话，前端直接通过nginx部署在服务器上，而后端是打成Docker Image。</p><h4 id="制作Docker-Image"><a href="#制作Docker-Image" class="headerlink" title="制作Docker Image"></a>制作Docker Image</h4><p>制作简单的Docker Image不复杂，这里我就拿我自己的这个项目来举个例子🌰</p><p>在项目目录下新建个Dockerfile的文件，下面👇是Dockerfile内容：</p><blockquote><p>Dockerfile 是一个用来构建镜像的文本文件，文本内容包含了一条条构建镜像所需的指令和说明。</p></blockquote><pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile"># 选择基础镜像FROM python:3.7# 指定作者LABEL maintainer&#x3D;&quot;DDDDanny&quot; # 配置工作目录WORKDIR &#x2F;usr&#x2F;src&#x2F;app# 拷贝目录下的文件至容器中COPY . .# 设置权限RUN chmod a+xr -R &#x2F;usr&#x2F;src&#x2F;app&#x2F;logs# 安装依赖包RUN pip3 install --no-cache-dir -r requirements.txt -i https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple# 执行gunicornCMD [&quot;gunicorn&quot;, &quot;app:app&quot;, &quot;-c&quot;, &quot;.&#x2F;gunicorn.conf.py&quot;]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Flask应用是在Gunicorn上部署的，所以最后执行的gunicorn。</p><p>写好Dockerfile后，直接Build就可以了。（Building过程中，可能会遇到各种各样的报错，如：TimeOut。。。遇到了就。。。按照报错提示百度就好，我就不再这一一说了，因为每个人执行的环境不同，报错也可能不一样，再说，你遇到了，我没遇到过🤪。不过遇到超时，建议再试一次）</p><p>Build完成后，我选择上传到DockerHub，这样方便获取，自己在DockerHub中建个仓库，上传就行（ 上传命令我就不写了，和Git差不多，我是直接使用IDE的，方便🤤 ）</p><p>上传成功，就完成了，接下来就是在想用的地方进行使用就行。</p><p>关于Dockerfile中的关键字详解，可以查询<a href="https://docs.docker.com/engine/reference/builder/">「Docker文档」</a></p>]]></content>
    
    
    <categories>
      
      <category>测试工具</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>你好👋 Docker（一）</title>
    <link href="/2020/09/15/HIDocker1/"/>
    <url>/2020/09/15/HIDocker1/</url>
    
    <content type="html"><![CDATA[<p>今天让我们来认识一下火了这么久的Docker。先来说说Docker是什么，Docker的组成，Docker的安装以及常用命令。👀</p><a id="more"></a><h3 id="Docker是什么"><a href="#Docker是什么" class="headerlink" title="Docker是什么"></a>Docker是什么</h3><p>​Docker 是一个开源的应用容器引擎，使用Go语言开发开源，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中,然后发布到任何流行的Linux机器或Windows 机器上,也可以实现虚拟化,容器是完全使用沙箱机制,相互之间不会有任何接口。</p><p>以上就是官方对Docker的解释，下面👇说说我的理解。</p><p>​运行Docker镜像后，会产生一个虚拟环境，此虚拟环境用来运行我们的应用。容器直接相互隔离，也相对独立，容器和容器之间可以进行通信，我认为这也是模块化的一种。</p><p>​总的来说Docker对于使用者来说，是非常友好的，不用考虑应用运行环境及配置，镜像下载完成后，运行生成容器即可使用，当然销毁也是非常方便的，减少了大部分部署配置的工作，大大提高了工作效率。</p><h3 id="Docker组成"><a href="#Docker组成" class="headerlink" title="Docker组成"></a>Docker组成</h3><p>Docker是由4部分组成：<strong>镜像（Image</strong>）、<strong>容器</strong>（<strong>Container</strong>）、<strong>网络</strong>（<strong>Network</strong>）、<strong>数据卷</strong>（<strong>Volume</strong>）</p><h4 id="镜像（Image）"><a href="#镜像（Image）" class="headerlink" title="镜像（Image）"></a>镜像（Image）</h4><p>镜像是可以理解为是一个可读的应用包，其中包含了虚拟环境运行的最原始文件系统的内容，其实也就是个完整的虚拟环境+应用文件。</p><p>每次对镜像的修改，Docker就会将这些镜像构成一个镜像层，一个镜像就是由下层镜像层所组成的，所以Docker镜像在实质上是没有被修改的，镜像修改后都会产生新的镜像，而并没有更改旧的镜像。</p><h4 id="容器（Container）"><a href="#容器（Container）" class="headerlink" title="容器（Container）"></a>容器（Container）</h4><p>运行镜像后，会生成相应的容器，就是类的实例化一样。</p><p>Docker容器由3个内容构成：</p><ol><li>一个Docker镜像</li><li>一个程序运行环境</li><li>一个指令集</li></ol><h4 id="网络（NetWork）"><a href="#网络（NetWork）" class="headerlink" title="网络（NetWork）"></a>网络（NetWork）</h4><p>Docker实现了非常强大的网络功能，不仅实现了容器与外部网络的通信，还实现了容器直接建立虚拟网络进行通信，同时与其他网络环境进行隔离</p><h4 id="数据卷（Volume）"><a href="#数据卷（Volume）" class="headerlink" title="数据卷（Volume）"></a>数据卷（Volume）</h4><p>Docker实现了文件系统目录的挂载，它能够从宿主操作系统中挂载目录外，还能够建立独立的目录持久存放数据，或者在容器间共享，实现了数据共享以及持久化的文件或目录</p><h3 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h3><blockquote><p>首先说明一下，虽然Docker在windows上可以安装使用（傻瓜式安装），但是使用起来实在是太不友好了，所以这里我只说Linux(Centos 7)下的安装过程</p></blockquote><ol><li><p>首先更新yum</p><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">&gt; sudo yum update<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>安装软件包yum-util、devicemapper的驱动</p><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">&gt; sudo yum install -y yum-utils device-mapper-persistent-data lvm2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>设置yum源</p><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">&gt; sudo yum-config-manager --add-repo https:&#x2F;&#x2F;download.docker.com&#x2F;linux&#x2F;centos&#x2F;docker-ce.repo<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>查看所有仓库中所有Docker版本（docker-ce的CE是指：Community Edition）</p><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">&gt; yum list docker-ce --showduplicates | sort -r<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>在列表中选择想要安装的Docker版本（我安装的<code>19.03.8</code>）</p><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">&gt; sudo yum install docker-ce-19.03.8.ce<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>安装完成后，启动Docker</p><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">&gt; sudo systemctl start docker  # 启动docker&gt; sudo systemctl enable docker  # 设置开机启动docker<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ol><p>至此，Docker就安装完成，没有什么难度，用起来比Windows环境的docker好100倍😏</p><h3 id="Docker的常用命令"><a href="#Docker的常用命令" class="headerlink" title="Docker的常用命令"></a>Docker的常用命令</h3><p>查看Docker镜像</p><pre class="line-numbers language-basic" data-language="basic"><code class="language-basic"><span class="token operator">></span> docker images<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看Docker容器的状态</p><pre class="line-numbers language-basic" data-language="basic"><code class="language-basic"><span class="token operator">></span> docker ps  # 查看正在运行的docker容器或<span class="token operator">></span> docker ps <span class="token operator">-</span>a  # 查看所有的docker容器<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>查看容器运行状态</p><pre class="line-numbers language-basic" data-language="basic"><code class="language-basic"><span class="token operator">></span> docker stats<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Docker容器的停止、启动、重启及删除</p><pre class="line-numbers language-basic" data-language="basic"><code class="language-basic"><span class="token operator">></span> docker <span class="token keyword">stop</span> 容器名称｜容器ID<span class="token operator">></span> docker start 容器名称｜容器ID<span class="token operator">></span> docker restart 容器名称｜容器ID<span class="token operator">></span> docker rm 容器名称｜容器ID<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Docker删除镜像</p><pre class="line-numbers language-basic" data-language="basic"><code class="language-basic"><span class="token operator">></span> docker rmi 镜像名称｜镜像ID<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Docker运行镜像生成容器</p><pre class="line-numbers language-basic" data-language="basic"><code class="language-basic"># <span class="token operator">-</span>p<span class="token punctuation">:</span> 端口映射，前面的是访问端口，后面是容器应用端口# <span class="token operator">-</span>d<span class="token punctuation">:</span> 后台运行容器# <span class="token operator">-</span>v<span class="token punctuation">:</span> 地址映射，前面是本机的地址，后面是容器内部地址，启动后，两个地址中的内容同步# <span class="token operator">-</span><span class="token operator">-</span><span class="token keyword">name</span><span class="token punctuation">:</span> 给这个容器起个名字$ docker <span class="token keyword">run</span> <span class="token operator">-</span>d <span class="token operator">-</span>p <span class="token number">8080</span><span class="token punctuation">:</span><span class="token number">8080</span> <span class="token operator">-</span>v <span class="token operator">/</span>xx<span class="token operator">/</span>xx<span class="token punctuation">:</span><span class="token operator">/</span>xx<span class="token operator">/</span>xx <span class="token operator">-</span><span class="token operator">-</span><span class="token keyword">name</span><span class="token operator">=</span>xxx 镜像名称｜镜像ID<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Docker进入镜像内部（以root身份进入）</p><pre class="line-numbers language-basic" data-language="basic"><code class="language-basic"><span class="token operator">></span> docker exec <span class="token operator">-</span>it <span class="token operator">-</span>u <span class="token number">0</span> 容器名称 bash<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>部分内容参考：<br><a href="https://zhuanlan.zhihu.com/p/57013691">「Docker」 - 核心组成</a></p>]]></content>
    
    
    <categories>
      
      <category>测试工具</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>S-UIAutoTest（实现篇）</title>
    <link href="/2020/09/10/SUIAutoTestDo/"/>
    <url>/2020/09/10/SUIAutoTestDo/</url>
    
    <content type="html"><![CDATA[<p>上一篇文章主要写了我怎么设计的这个UI自动化测试框架，下面👇我来说说S-UIAutoTest具体的实现和使用。</p><a id="more"></a><h3 id="实现篇"><a href="#实现篇" class="headerlink" title="实现篇"></a>实现篇</h3><p>⚠️说在前面：</p><blockquote><p>编写UI自动化测试脚本，有三点非常重要：</p><ul><li>编写UI自动化测试脚本前，一定要是<code>熟悉业务</code>的，因为脱离了业务，任何自动化测试也变的没有了意义</li><li>定位元素不能仅限于定位到就可以，要去考虑使用的定位方式是否合理，维护成本是否很高</li><li>在编写UI自动化测试脚本时，要考虑逻辑是否可以复用，时间和空间复杂度如何，是否可以降低</li></ul></blockquote><p>下面👇我开始写如何实现UI自动化测试。</p><ol><li><p>选择定位方式</p><p>目前，框架中已经封装了一些常用的定位方式，其中最常用的是通过ClassName、Css选择器、Id这3中。具体使用哪一种定位方式，需要根据具体情况分析进行判断。</p></li><li><p>元素定位</p><p>要定位元素，首先要找到元素，浏览器F12进行操作即可，具体就不赘述了。找到元素后，要判断如何选择定位方式是合理的，这里有个基本原则，定位出来的元素总数不要过多，比如，你用ClassName定位，找出页面中有20多个元素，这就是不合理的，原则上是尽可能定位出只有1个元素，所以建议使用Css选择器进行定位。</p><p>在浏览器中找元素，可以在浏览器开发者工具中的Console中去找：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">document<span class="token punctuation">.</span><span class="token function">querySelectorAll</span><span class="token punctuation">(</span><span class="token string">'.HellWorld'</span><span class="token punctuation">)</span>  # 通过css选择器# 也可以通过下方这些方法来找元素document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span>document<span class="token punctuation">.</span><span class="token function">getElementsByClassName</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span>document<span class="token punctuation">.</span><span class="token function">getElementsByName</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span>document<span class="token punctuation">.</span><span class="token function">getElementsByTagName</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>编写Page层</p><p>元素找到后，写进Ele_config.ini配置文件即可：</p><pre class="line-numbers language-ini" data-language="ini"><code class="language-ini"><span class="token selector">[PageName]</span>  # 与页面名称一致<span class="token constant">UserName</span> <span class="token attr-value"><span class="token punctuation">=</span> css>.el-input__inner>0</span><span class="token constant">PassWord</span> <span class="token attr-value"><span class="token punctuation">=</span> classname>el-input__inner>1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>之后，在Page层按照页面名称xxx_page.py进行命名：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> PySe<span class="token punctuation">.</span>operation <span class="token keyword">import</span> PySelenium  <span class="token comment"># 这是selenium的二次封装</span><span class="token comment"># 登录&amp;退出</span><span class="token keyword">class</span> <span class="token class-name">LoginPage</span><span class="token punctuation">(</span><span class="token builtin">object</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment"># 类名与页面名称一致</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> driver<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>element <span class="token operator">=</span> PySelenium<span class="token punctuation">(</span>driver<span class="token punctuation">)</span>    <span class="token comment"># 清空输入框</span>    <span class="token keyword">def</span> <span class="token function">clear_input</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment"># 根据页面操作进行命名</span>        self<span class="token punctuation">.</span>element<span class="token punctuation">.</span>element_clear<span class="token punctuation">(</span><span class="token string">'Login'</span><span class="token punctuation">,</span> <span class="token string">'UserName'</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>element<span class="token punctuation">.</span>element_clear<span class="token punctuation">(</span><span class="token string">'Login'</span><span class="token punctuation">,</span> <span class="token string">'PassWord'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>具体PySelenium中的代码可以在<a href="https://github.com/DDDDanny/S-UIAutoTest/blob/master/PySe/operation.py">这里</a>查看</p></blockquote></li><li><p>接下来编写业务逻辑</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> Test<span class="token punctuation">.</span>Page<span class="token punctuation">.</span>login_page <span class="token keyword">import</span> LoginPage<span class="token keyword">class</span> <span class="token class-name">LoginBusiness</span><span class="token punctuation">(</span><span class="token builtin">object</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment"># 根据业务场景进行命名</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> driver<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>login_Business <span class="token operator">=</span> LoginPage<span class="token punctuation">(</span>driver<span class="token punctuation">)</span>    <span class="token comment"># 登录成功</span>    <span class="token keyword">def</span> <span class="token function">login_suc</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> username<span class="token punctuation">,</span> password<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment"># 根据业务流程进行命名</span>        self<span class="token punctuation">.</span>login_Business<span class="token punctuation">.</span>clear_input<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>login_Business<span class="token punctuation">.</span>send_username<span class="token punctuation">(</span>username<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>login_Business<span class="token punctuation">.</span>send_password<span class="token punctuation">(</span>password<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>login_Business<span class="token punctuation">.</span>click_submit<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>login_Business<span class="token punctuation">.</span>get_org_name<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 数据传递，一般情况下用于断言，当需要返回的多个数据时，使用list或tuple进行传递</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>编写测试用例基类</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">LoginBaseCase</span><span class="token punctuation">(</span>unittest<span class="token punctuation">.</span>TestCase<span class="token punctuation">)</span><span class="token punctuation">:</span>    driver <span class="token operator">=</span> <span class="token boolean">None</span>    <span class="token decorator annotation punctuation">@classmethod</span>    <span class="token decorator annotation punctuation">@LogInfo<span class="token punctuation">.</span>get_error</span>    <span class="token keyword">def</span> <span class="token function">setUpClass</span><span class="token punctuation">(</span>cls<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token boolean">None</span><span class="token punctuation">:</span>  <span class="token comment"># 用例集开始执行时运行</span>        <span class="token comment"># 初始化开始</span>        LogInfo<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>log<span class="token punctuation">.</span>info<span class="token punctuation">(</span><span class="token string">'Initialization Start'</span><span class="token punctuation">)</span>        cls<span class="token punctuation">.</span>driver <span class="token operator">=</span> SelectBrowser<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span>select_browser<span class="token punctuation">(</span>Browser<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        cls<span class="token punctuation">.</span>dr <span class="token operator">=</span> PySelenium<span class="token punctuation">(</span>cls<span class="token punctuation">.</span>driver<span class="token punctuation">)</span>        cls<span class="token punctuation">.</span>dr<span class="token punctuation">.</span>test_url<span class="token punctuation">(</span>ReadIni<span class="token punctuation">(</span><span class="token string">'Sys_config.ini'</span><span class="token punctuation">,</span> Evn<span class="token punctuation">)</span><span class="token punctuation">.</span>get_value<span class="token punctuation">(</span><span class="token string">'website_url'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        cls<span class="token punctuation">.</span>dr<span class="token punctuation">.</span>maximize_window<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment"># 初始化完成</span>        LogInfo<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>log<span class="token punctuation">.</span>info<span class="token punctuation">(</span><span class="token string">'Initialization Completed'</span><span class="token punctuation">)</span>        <span class="token comment"># 登录业务流程-测试用例</span>        LogInfo<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>log<span class="token punctuation">.</span>info<span class="token punctuation">(</span><span class="token string">'Login Cases Suite Start'</span><span class="token punctuation">)</span>        cls<span class="token punctuation">.</span>login <span class="token operator">=</span> LoginBusiness<span class="token punctuation">(</span>cls<span class="token punctuation">.</span>driver<span class="token punctuation">)</span>    <span class="token decorator annotation punctuation">@classmethod</span>    <span class="token decorator annotation punctuation">@LogInfo<span class="token punctuation">.</span>get_error</span>    <span class="token keyword">def</span> <span class="token function">tearDownClass</span><span class="token punctuation">(</span>cls<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token boolean">None</span><span class="token punctuation">:</span>  <span class="token comment"># 用例集结束执行时运行</span>        cls<span class="token punctuation">.</span>driver<span class="token punctuation">.</span>quit<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>编写测试用例</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> unittest<span class="token keyword">from</span> Utils<span class="token punctuation">.</span>get_log <span class="token keyword">import</span> LogInfo<span class="token keyword">from</span> Utils<span class="token punctuation">.</span>read_ini <span class="token keyword">import</span> ReadIni<span class="token keyword">from</span> Utils<span class="token punctuation">.</span>global_value <span class="token keyword">import</span> Evn<span class="token keyword">from</span> Test<span class="token punctuation">.</span>Case<span class="token punctuation">.</span>base_case <span class="token keyword">import</span> LoginBaseCase<span class="token comment"># 继承测试用例基类，测试用例基类主要是用于初始化数据及前置和后置条件</span><span class="token keyword">class</span> <span class="token class-name">LoginCase</span><span class="token punctuation">(</span>LoginBaseCase<span class="token punctuation">,</span> LogInfo<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment"># 根据测试场景进行命名</span>    <span class="token triple-quoted-string string">""" 登录&amp;退出测试用例 """</span>  <span class="token comment"># 注释一定要写，它会反馈到测试报告中</span>    <span class="token decorator annotation punctuation">@LogInfo<span class="token punctuation">.</span>get_error</span>    <span class="token keyword">def</span> <span class="token function">test_1</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment"># 测试用例是以test_数字进行命名</span>        <span class="token triple-quoted-string string">""" 登录流程 """</span>  <span class="token comment"># 注释一定要写，它会反馈到测试报告中</span>        self<span class="token punctuation">.</span>log<span class="token punctuation">.</span>info<span class="token punctuation">(</span><span class="token string">'TestCase1 Start Running'</span><span class="token punctuation">)</span>        <span class="token comment"># 获取用户名和密码</span>        username <span class="token operator">=</span> ReadIni<span class="token punctuation">(</span><span class="token string">'Sys_config.ini'</span><span class="token punctuation">,</span> Evn<span class="token punctuation">)</span><span class="token punctuation">.</span>get_value<span class="token punctuation">(</span><span class="token string">'username'</span><span class="token punctuation">)</span>        password <span class="token operator">=</span> ReadIni<span class="token punctuation">(</span><span class="token string">'Sys_config.ini'</span><span class="token punctuation">,</span> Evn<span class="token punctuation">)</span><span class="token punctuation">.</span>get_value<span class="token punctuation">(</span><span class="token string">'password'</span><span class="token punctuation">)</span>        <span class="token comment"># 获取Org名称</span>        org_name <span class="token operator">=</span> self<span class="token punctuation">.</span>login<span class="token punctuation">.</span>login_suc<span class="token punctuation">(</span>username<span class="token punctuation">,</span> password<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>assertEqual<span class="token punctuation">(</span><span class="token string">'Hello World'</span><span class="token punctuation">,</span> org_name<span class="token punctuation">,</span> <span class="token string">'说明文字不一致 --- 测试用例不通过'</span><span class="token punctuation">)</span>    <span class="token decorator annotation punctuation">@LogInfo<span class="token punctuation">.</span>get_error</span>    <span class="token keyword">def</span> <span class="token function">test_2</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">""" 退出流程 """</span>        self<span class="token punctuation">.</span>log<span class="token punctuation">.</span>info<span class="token punctuation">(</span><span class="token string">'TestCase2 Start Running'</span><span class="token punctuation">)</span>        welcome <span class="token operator">=</span> self<span class="token punctuation">.</span>login<span class="token punctuation">.</span>logout_suc<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>assertEqual<span class="token punctuation">(</span><span class="token string">'欢迎登录'</span><span class="token punctuation">,</span> welcome<span class="token punctuation">,</span> <span class="token string">'首页欢迎语句错误 --- 测试用例不通过'</span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    unittest<span class="token punctuation">.</span>main<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h3><ul><li>相对于其他自动化测试，UI自动测试是一项成本较高的测试活动，所以是否需要做UI自动化测试，是要根据实际项目和产品来确定，还需要考虑人力资源的成本；</li><li>UI自动化测试，整体来看没有什么难点，按照规则写就好。我认为，UI自动化测试最难最重要的就是元素定位，要在合适的地方用合适的方式去定位，才能达到最好的效果；</li><li>UI自动化测试稳定性是在中后期很重要的一件事，当测试用例越来越多，场景变的越来越复杂时，还有一些客观因素的存在，就会导致UI自动化测试的稳定性逐渐下降。稳定性下降是不可避免的，这是UI自动化测试弊端，但是我们要控制它下降的范围，我认为，500条用例的稳定性应该在（成功率）99.99%以上。所以，我们在写用例脚本时，应该去注意一些可能会影响稳定性的东西，比如说适当差分业务流程复杂的用例，删除一些稳定性很差的用例等；</li><li>我希望，这篇文章能对WebUI自动化测试感兴趣的人起到一点点🤏的帮助</li><li>写到现在，发现还有一些不是很好用的地方，我计划过段时间再次优化一下这个框架，嘿嘿～</li></ul>]]></content>
    
    
    <categories>
      
      <category>自动化测试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>S-UIAutoTest（框架篇）</title>
    <link href="/2020/09/05/SUIAutoTestDesign/"/>
    <url>/2020/09/05/SUIAutoTestDesign/</url>
    
    <content type="html"><![CDATA[<p>上一篇文章主要写了，我为什么要做这个UI自动化测试框架，下面👇我来说说这个框架的构成。</p><a id="more"></a><h3 id="框架篇"><a href="#框架篇" class="headerlink" title="框架篇"></a>框架篇</h3><h4 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h4><p>​我所编写的UI自动化测试框架<code>S-UIAutoTest</code>是基于<code>Python3.7</code> +  <code>Selenium</code> + <code>unittest</code> ，采用PO设计模式，将页面与用例进行分离，提高代码复用性，降低了代码的维护成本。</p><h4 id="元素管理"><a href="#元素管理" class="headerlink" title="元素管理"></a>元素管理</h4><p>​我采用的是使用ini配置文件进行管理，因为它符合使用场景（节点代表页面、键值对代表元素），并且不依赖环境，使用和维护方便，所以最终我选择了使用ini配置文件对元素进行管理。</p><h4 id="页面层（Page）"><a href="#页面层（Page）" class="headerlink" title="页面层（Page）"></a>页面层（Page）</h4><p>​Page层与页面是有直接关系的，所以在写Page层的时候，一定要注重页面元素层级等等信息，找到规律、特性，这样才能写出复用性高、维护成本低的定位。</p><h4 id="业务层（Business）"><a href="#业务层（Business）" class="headerlink" title="业务层（Business）"></a>业务层（Business）</h4><p>​Business层是组装Page层元素的地方，根据测试用例，编写相应的测试业务逻辑（所有的判断和循环逻辑都写在这里）</p><h4 id="用例层（Case）"><a href="#用例层（Case）" class="headerlink" title="用例层（Case）"></a>用例层（Case）</h4><p>​Case层就是最终的测试用例层，由于主要的业务流程都在业务层（Business层）处理完成，所以Case层只需要进行Mock数据的生成和调用业务逻辑即可</p><h4 id="PySelenium"><a href="#PySelenium" class="headerlink" title="PySelenium"></a>PySelenium</h4><p>​Page层是建立在PySelenium之上的，PySelenium是对selenium的二次封装，它主要的工作就是用来处理元素定位和操作元素。PySelenium是整个框架的核心模块。</p><h4 id="其他模块"><a href="#其他模块" class="headerlink" title="其他模块"></a>其他模块</h4><h5 id="生成并发送测试报告"><a href="#生成并发送测试报告" class="headerlink" title="生成并发送测试报告"></a>生成并发送测试报告</h5><p>​测试报告是基于HTMLTestRunner生成的，生成报告后，通过邮件发送给指定人员。</p><h5 id="生成打印日志"><a href="#生成打印日志" class="headerlink" title="生成打印日志"></a>生成打印日志</h5><p>​日志信息的打印以及生成日志文件，我是基于logging写的日志生成器，实现打印各个等级的日志信息，并通过装饰器实现了捕获异常的功能。</p><p>以上就是<code>S-UIAutoTest</code>框架的组成和结构。</p>]]></content>
    
    
    <categories>
      
      <category>自动化测试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>S-UIAutoTest（需求篇）</title>
    <link href="/2020/09/01/SUIAutoTest/"/>
    <url>/2020/09/01/SUIAutoTest/</url>
    
    <content type="html"><![CDATA[<p>根据各种需求，我编写了WebUI自动化测试框架<a href="https://github.com/DDDDanny/S-UIAutoTest">S-UIAutoTest</a>，实现了WebUI自动化测试。这个系列文章，我会把我实现的整个过程都回顾记录下来，把知识和技能沉淀一下。</p><a id="more"></a><h3 id="需求篇"><a href="#需求篇" class="headerlink" title="需求篇"></a>需求篇</h3><h4 id="为什么要做UI自动化测试呢？"><a href="#为什么要做UI自动化测试呢？" class="headerlink" title="为什么要做UI自动化测试呢？"></a>为什么要做UI自动化测试呢？</h4><p>众所周知，测试金字塔中，UI层是在最顶部的，那么就意味这它是实施成本最高、维护成本最高，执行速度最慢的。而且UI自动化测试是在前端开发完成后执行，在发现Bug后，开发修复Bug的成本也是比较高的。</p><p>在这么多弊端的情况下，为什么还要选择UI自动化测试呢？</p><p>先肯定一点，做UI自动化测试是有价值的。</p><p>首先，做UI自动化测试并不是为了找Bug而去做的，而是为了提高测试人员的<code>测试效率</code>去做，它能够直接减少测试人员的工作量。UI自动化测试的使用场景大多是在冒烟测试和回归测试中，以保证基础功能和主要流程能够正常。</p><p>在迭代过程中，测试人员只需要关心迭代的内容，而基础功能和主要流程的测试就可以交给UI自动化测试去完成。</p><p>当产品的功能越来越多，越来越复杂的时候，UI自动化测试的价值就会越大。</p><p>有这么一种场景：</p><blockquote><p>开发人员要修改一个基础功能，这个功能在系统中有多处用到，他在修改的时候，漏掉了一个地方。</p><p>提测后，测试人员也遗漏了。</p><p>上线后，用户反馈功能使用不了，这时开发和测试才想起：还有这个地方没有改到呀！！！😨</p></blockquote><p>对于上面这种场景，我相信很多人都遇到过，当产品功能越来越多的时候，UI自动化测试的价值就越来越大，它能够保证重要及主要流程能够正常跑通，基础功能能够正常使用。</p><p>话说回来，当系统功能不多时，完全没有必要去做UI自动化测试，因为成本实在太高了！</p><p>怎么样算是系统功能不多呢？我个人认为，在回归测试中，只要手工测试能够在40min内完成就算系统功能不多。（根据心理学观点，成人注意力持续集中只有30—50分钟，超过这个时间，回归测试的准确度就会降低）</p>]]></content>
    
    
    <categories>
      
      <category>自动化测试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>对于软件测试的一些感悟</title>
    <link href="/2020/06/13/ForTester/"/>
    <url>/2020/06/13/ForTester/</url>
    
    <content type="html"><![CDATA[<p>我从事软件测试已经有4年了，干了这么久，多多少少有一些感悟。写这篇文章，是想说说我对软件测试的一下想法和感悟，其实主要想吐槽和说说现实😄</p><a id="more"></a><h3 id="初识软件测试"><a href="#初识软件测试" class="headerlink" title="初识软件测试"></a>初识软件测试</h3><p>我初识软件测试是在大学中，我参加了一次软件测试实训项目，从那个时候开始，我就对软件测试很感兴趣了，为什么呢？我觉得是主要有两点原因的：</p><ul><li>我自身的性格非常符合软件测试这个工作</li><li>它能给我带来一种成就感（ 最先使用到这个新功能的人😄 ）</li></ul><h3 id="软件测试难吗？有必要吗？"><a href="#软件测试难吗？有必要吗？" class="headerlink" title="软件测试难吗？有必要吗？"></a>软件测试难吗？有必要吗？</h3><p>通过第一次接触后，我觉得软件测试是一个非常具有挑战性的工作，而且想做好软件测试是非常不容易的。</p><p>但是很多人都认为，软件测试是一个非常简单的工作，说的简单点就是他只需要点点点，仔细一点就好。我觉得这么看软件测试的人，根本不了解什么是软件测试，根本不重视测试。</p><p>很多公司都没有软件测试的岗位，测试工作都是由开发完成的，虽然这样可以降低成本，但是软件质量保证不了，很大可能性导致损失的收益高于了测试人员的人力成本。</p><p>在现在这个时代，很多人都在做相同的产品，那么用户为什么选择使用你的产品呢？？？我认为有主要有三点原因：</p><ul><li>你的产品功能是用户所需要的（很多产品都会有相同的功能，所以这个并没有很大的优势）</li><li>你的价格很吸引用户（这个也不好去突破，因为成本放在那里）</li><li>你的产品质量很好（这个就是一个有力的竞争点）</li></ul><p>通过前两点，很难和其他产品拉开差距，那么只有通过软件产品质量来拉开差距，来让用户选择你。</p><p>软件测试的入门门槛很低，但是想把它做好很难。在最近这几年，相同的软件越来越多，而且人们对软件的质量要求越来越高，软件测试也越来越被重视，软件测试工程师也就成为了开发团队必不可少的成员。</p><h3 id="大大小小的坑"><a href="#大大小小的坑" class="headerlink" title="大大小小的坑"></a>大大小小的坑</h3><h4 id="不要完全相信开发说的话"><a href="#不要完全相信开发说的话" class="headerlink" title="不要完全相信开发说的话"></a>不要完全相信开发说的话</h4><p>​哈哈，这个坑是最有意思的。即使有完整的需求文档，即使改动很小，每个迭代开发阶段完成后，一定要去看看或者去问问，开发改了哪些地方，当然，这里是可信的，不可信的是开发人员说：“没事，这个地方你只用看看正常使用是否可以就行了”，一般这么说，我都慌的一批，因为很大可能性开发也不知道它会影响到什么地方🙄️，最后出问题了，他会说：“我就改了一行代码。。。怎么还影响到那里了呀”。</p><p>​所以不要完全相信开发说的话，在这种情况下，我们需要根据我们以往的经验和对产品的了解，来自己判断修改后的代码，会影响到哪些地方。</p><h4 id="不要抱有侥幸心理"><a href="#不要抱有侥幸心理" class="headerlink" title="不要抱有侥幸心理"></a>不要抱有侥幸心理</h4><p>这个侥幸心理指的是：</p><ul><li>我偷个懒，不测这个东西了，反正这次迭代也没有改这里</li><li>或是测试通过了一两种异常操作后，就放弃了对其他异常操作的测试，觉得不会有问题了</li></ul><p>往往抱有侥幸心理的时候，上线后，它很大概率会出问题！！！就是这么邪！</p><p>所以还是要认认真真的完成每一次测试任务，千万被抱有侥幸心理！</p><h4 id="测试的日常加班陪跑"><a href="#测试的日常加班陪跑" class="headerlink" title="测试的日常加班陪跑"></a>测试的日常加班陪跑</h4><p>测试加班陪跑是一件很难受的事，当开发流程并没有那么完善时，发布程序，可能会遇到各种问题，然后测试就在那等，一般等的时间都会超过回归测试的时间😅。。。</p><h4 id="冒烟测试一定要严格"><a href="#冒烟测试一定要严格" class="headerlink" title="冒烟测试一定要严格"></a>冒烟测试一定要严格</h4><p>当没有冒烟测试或是冒烟测试不严格时，测试的时间一定会被压缩，被压缩的后果就是加班或是发布后的程序质量不高。所以冒烟测试一定要严格，冒烟测试不通过，直接打回重做！</p><h4 id="回归测试一定要做"><a href="#回归测试一定要做" class="headerlink" title="回归测试一定要做"></a>回归测试一定要做</h4><p>回归测试是一件非常重要的一件事，因为程序在上线后，可能会出现在之前测试过程中没有的Bug，还会发现一些没有发现的Bug。如果你偷懒没有做一部分的回归测试，很大可能性，这个地方会出问题，别问为什么，问就是遇到过。所以回归测试提升软件质量的一个重要阶段，一定要认真对待。</p><h3 id="关于研发-amp-测试流程"><a href="#关于研发-amp-测试流程" class="headerlink" title="关于研发&amp;测试流程"></a>关于研发&amp;测试流程</h3><p>​我所知道的比较完整的研发&amp;测试流程是这样的：</p><blockquote><p>需求调研、可行性分析、需求评审、UI评审、用例评审、开发阶段、冒烟测试、测试阶段、ShowCase、发布上线、回归测试、迭代复盘</p></blockquote><p>​这一套流程我认为是比较完整的，看似很简单，但是能够落地是很困难的，这里需要很多人的支持和互相磨合才能够真正的落地实施。有一套完整的研发&amp;测试流程，是一定可以提高整个迭代效率的。</p><p>​对于一些小公司来说，可能都没有测试人员，就更别提有完整的研发&amp;测试流程了，这是非常正常的，也别抱怨工作效率低，这也许是对你能力提升的一个机会！</p><h3 id="关于职业规划"><a href="#关于职业规划" class="headerlink" title="关于职业规划"></a>关于职业规划</h3><p>软件测试有三个大的发展方向：管理岗、技术岗和转行</p><p>软件测试有三个阶段：功能测试工程师、自动化测试工程师和测试开发工程师</p><p>三个阶段并不是说我们必须提升编程技能，来通过三个阶段，如果你在某一个阶段干的非常非常好，也是没有问题的，但是你不可以不了解它们，你懂的。</p><p>当你对编程没有什么兴趣，对技术没有渴求时，我建议别走技术路线了，因为即使强行走了，也是走不远的，而且它会因为你的没有兴趣，而变得复杂、累赘、疲惫。。。</p><p>具体往哪个方向发展，需要根据自身的条件来判断。无论你选择哪个方向，软件测试最重要的是对<code>业务</code>的熟悉，当你对业务非常熟悉时，你的价值才会逐渐提升。</p><p>当然如果你干了一段时间，发现这个工作不适合你，那么你也可以选择转行。</p><h3 id="软件测试态度"><a href="#软件测试态度" class="headerlink" title="软件测试态度"></a>软件测试态度</h3><p>关于软件测试态度，我只想说一个概念“工匠精神”。</p><p>什么是工匠精神呢，我这里用几个关键词来概括一下：<code>敬业</code>、<code>高要求</code>、<code>注重细节</code>、<code>追求完美</code>、<code>执着</code></p><p>做软件测试一定要有工匠精神，因为我们是最后的把关者，从我们手里出去的软件产品，就是要面向用户的，所以我们的工作和态度非常重要。虽然说一个产品不可能没有Bug，但是作为测试，我们不应该这么想，我们应该追求完美，追求零Bug，这才是我们测试人员该有的态度。</p><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>以上所说的只是我个人的一些感悟，希望所有的软件测试工程师，不要太累，放平心态，注意身体😄</p>]]></content>
    
    
    <categories>
      
      <category>测试经验</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Python实现日志记录功能</title>
    <link href="/2019/08/25/PythonLogNote/"/>
    <url>/2019/08/25/PythonLogNote/</url>
    
    <content type="html"><![CDATA[<p>最近在写接口自动化框架，需要日志记录功能，就研究了下，写的不算特别好，遵从先实现再优的原则嘛😜，这次呢，我就说下我实现的整个过程。</p><a id="more"></a><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>主要需求嘛，就两点：</p><ol><li>在控制台能够打印日志，方便debug</li><li>将日志写入在文件中，方便部署后查找问题</li></ol><p>其他拓展需求嘛，有三点：</p><ol><li>能够控制日志等级进行日志输出</li><li>能够捕获系统错误并进行日志输出</li><li>有可以控制是否输出到文件的开关</li></ol><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>两个主要需求都很好实现，主要用到的是python内置的logging模块，logging模块内容比较多，在网上很好找，就不在这赘述了。</p><p>不多说，直接上代码🧐</p><h3 id="Log生成及输出：get-logs-py"><a href="#Log生成及输出：get-logs-py" class="headerlink" title="Log生成及输出：get_logs.py"></a>Log生成及输出：get_logs.py</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> os<span class="token keyword">import</span> logging<span class="token keyword">class</span> <span class="token class-name">TestLogs</span><span class="token punctuation">(</span><span class="token builtin">object</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>logger <span class="token operator">=</span> logging<span class="token punctuation">.</span>getLogger<span class="token punctuation">(</span>__name__<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>logger<span class="token punctuation">.</span>setLevel<span class="token punctuation">(</span>logging<span class="token punctuation">.</span>DEBUG<span class="token punctuation">)</span>        <span class="token comment"># 设置日志输出格式</span>        formatter <span class="token operator">=</span> logging<span class="token punctuation">.</span>Formatter<span class="token punctuation">(</span>            <span class="token string">'[%(asctime)s]-[%(levelname)s] %(filename)s--> %(funcName)s ----->%(message)s'</span>        <span class="token punctuation">)</span>        <span class="token comment"># 设置控制台日志信息</span>        console <span class="token operator">=</span> logging<span class="token punctuation">.</span>StreamHandler<span class="token punctuation">(</span><span class="token punctuation">)</span>        console<span class="token punctuation">.</span>setFormatter<span class="token punctuation">(</span>formatter<span class="token punctuation">)</span>        <span class="token comment"># 设置级别日志级别,Logging中有NOTSET &lt; DEBUG &lt; INFO &lt; WARNING &lt; ERROR &lt; CRITICAL这几种级别，日志会记录设置级别以上的日志</span>        console<span class="token punctuation">.</span>setLevel<span class="token punctuation">(</span>logging<span class="token punctuation">.</span>DEBUG<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>logger<span class="token punctuation">.</span>addHandler<span class="token punctuation">(</span>console<span class="token punctuation">)</span>        <span class="token comment"># 生成日志文件的开关，为debug模式，不生成文件</span>        <span class="token keyword">if</span> GetValue<span class="token punctuation">.</span>is_debug <span class="token operator">==</span> <span class="token string">'False'</span><span class="token punctuation">:</span>            <span class="token comment"># 生成文件路径</span>            file_name <span class="token operator">=</span> datetime<span class="token punctuation">.</span>datetime<span class="token punctuation">.</span>now<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>strftime<span class="token punctuation">(</span><span class="token string">"%Y-%m-%d"</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">".log"</span>            <span class="token comment"># 获取当前目录的绝对路径</span>            cur_path <span class="token operator">=</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>abspath<span class="token punctuation">(</span>__file__<span class="token punctuation">)</span>            <span class="token comment"># 获取logs文件夹的绝对路径</span>            logs_path <span class="token operator">=</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span>os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>abspath<span class="token punctuation">(</span>os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>dirname<span class="token punctuation">(</span>cur_path<span class="token punctuation">)</span> <span class="token operator">+</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>sep <span class="token operator">+</span> <span class="token string">'../logs/'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">)</span>            <span class="token comment"># 设置文件日志信息</span>            file_handle <span class="token operator">=</span> logging<span class="token punctuation">.</span>FileHandler<span class="token punctuation">(</span>logs_path <span class="token operator">+</span> file_name<span class="token punctuation">,</span> mode<span class="token operator">=</span><span class="token string">'a'</span><span class="token punctuation">,</span> encoding<span class="token operator">=</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span>            file_handle<span class="token punctuation">.</span>setFormatter<span class="token punctuation">(</span>formatter<span class="token punctuation">)</span>            file_handle<span class="token punctuation">.</span>setLevel<span class="token punctuation">(</span>logging<span class="token punctuation">.</span>INFO<span class="token punctuation">)</span>            self<span class="token punctuation">.</span>logger<span class="token punctuation">.</span>addHandler<span class="token punctuation">(</span>file_handle<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">get_log</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>logger<span class="token keyword">class</span> <span class="token class-name">LogInfo</span><span class="token punctuation">(</span><span class="token builtin">object</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    log <span class="token operator">=</span> TestLogs<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>get_log<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    logger <span class="token operator">=</span> TestLogs<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>get_log<span class="token punctuation">(</span><span class="token punctuation">)</span>    logger<span class="token punctuation">.</span>debug<span class="token punctuation">(</span><span class="token string">'this is a debug log'</span><span class="token punctuation">)</span>    logger<span class="token punctuation">.</span>info<span class="token punctuation">(</span><span class="token string">'this is a info log'</span><span class="token punctuation">)</span>    logger<span class="token punctuation">.</span>error<span class="token punctuation">(</span><span class="token string">'this is a error log'</span><span class="token punctuation">)</span>    logger<span class="token punctuation">.</span>warning<span class="token punctuation">(</span><span class="token string">'this is a warning log'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说明：</p><ol><li>代码中GetValue是一个我自己写的读取ini配置文件的类，读取is_debug的值，作为是否成功文件日志的开关；</li><li>生成文件名称时，我把日志时间格式化了一下，格式化前：2019-08-25 21:55:48,897；</li><li>在设置文件日志的时候，一定要设置encoding=’utf-8’，不然会乱码；</li><li>LogInfo这个类是为了方便之后在其他文件中使用而写，只要继承这个类，就直接可以使用；</li><li>顺带提一下，这里文件路径，我用的是绝对路径，因为这里如果使用相对路径，会有个巨大的坑（单独运行测试用例报错）</li></ol><h3 id="get-logs-py的使用"><a href="#get-logs-py的使用" class="headerlink" title="get_logs.py的使用"></a>get_logs.py的使用</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> common<span class="token punctuation">.</span>get_log <span class="token keyword">import</span> LogInfo<span class="token keyword">class</span> <span class="token class-name">LoginApiTest</span><span class="token punctuation">(</span>unittest<span class="token punctuation">.</span>TestCase<span class="token punctuation">,</span> GetValue<span class="token punctuation">,</span> LogInfo<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""登录接口"""</span>    <span class="token keyword">def</span> <span class="token function">test_1</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""账号密码正确"""</span>        r <span class="token operator">=</span> requests<span class="token punctuation">.</span>post<span class="token punctuation">(</span>self<span class="token punctuation">.</span>url<span class="token punctuation">,</span> data<span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token string">"password"</span><span class="token punctuation">:</span> self<span class="token punctuation">.</span>password<span class="token punctuation">,</span> <span class="token string">"userName"</span><span class="token punctuation">:</span> self<span class="token punctuation">.</span>username<span class="token punctuation">&#125;</span><span class="token punctuation">)</span>        result <span class="token operator">=</span> r<span class="token punctuation">.</span>json<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment"># 打印日志</span>        self<span class="token punctuation">.</span>log<span class="token punctuation">.</span>debug<span class="token punctuation">(</span>result<span class="token punctuation">)</span>        code <span class="token operator">=</span> r<span class="token punctuation">.</span>status_code        self<span class="token punctuation">.</span>assertEqual<span class="token punctuation">(</span>code<span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>assertEqual<span class="token punctuation">(</span>result<span class="token punctuation">[</span><span class="token string">'data'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'name'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">'username'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说明：这是在测试用例中使用，继承了LogInfo，直接self.log就可以使用写日志了。</p><h3 id="输出异常日志"><a href="#输出异常日志" class="headerlink" title="输出异常日志"></a>输出异常日志</h3><p>我在LogInfo下写了个装饰器专门处理异常日志</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> functools<span class="token keyword">import</span> traceback<span class="token keyword">class</span> <span class="token class-name">LogInfo</span><span class="token punctuation">(</span><span class="token builtin">object</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    log <span class="token operator">=</span> TestLogs<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>get_log<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token decorator annotation punctuation">@classmethod</span>    <span class="token keyword">def</span> <span class="token function">get_error</span><span class="token punctuation">(</span>cls<span class="token punctuation">,</span> func<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        get_error装饰器，用于获取错误信息并且写入日志        :param func: 入参函数        :return:        """</span>        <span class="token decorator annotation punctuation">@functools<span class="token punctuation">.</span>wraps</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span>        <span class="token keyword">def</span> <span class="token function">wrapper_func</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">try</span><span class="token punctuation">:</span>                func<span class="token punctuation">(</span>self<span class="token punctuation">)</span>            <span class="token keyword">except</span> Exception<span class="token punctuation">:</span>                self<span class="token punctuation">.</span>log<span class="token punctuation">.</span>error<span class="token punctuation">(</span>traceback<span class="token punctuation">.</span>format_exc<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">raise</span> Exception<span class="token punctuation">(</span><span class="token string">'系统出现异常，请及时处理！'</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> wrapper_func<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说明：简单地说，测试用例作为func传进来，执行try…except…，达到输出异常日志的目的。哦，这里用到了traceback模块，它专门用来获取异常信息。traceback模块详细的内容，网上有很多，我就不再赘述了。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> common<span class="token punctuation">.</span>get_log <span class="token keyword">import</span> LogInfo<span class="token keyword">class</span> <span class="token class-name">LoginApiTest</span><span class="token punctuation">(</span>unittest<span class="token punctuation">.</span>TestCase<span class="token punctuation">,</span> GetValue<span class="token punctuation">,</span> LogInfo<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""登录接口"""</span>    <span class="token decorator annotation punctuation">@LogInfo<span class="token punctuation">.</span>get_error</span>    <span class="token keyword">def</span> <span class="token function">test_1</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说明：直接使用装饰器即可，当系统抛出异常时，就可以记录日志啦😝</p><p>至此，5点需求就全部完成。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一般日志我使用继承的方式实现，日志可随意添加；异常日志我使用装饰器的方式，对每一个测试用例进行监控。</p><p>目前，我个人认为，我采用的方式算是比较好的，添加日志也比较顺手。</p><p>之后在使用的过程中，我会继续优化，让它变得更好，更优美😏</p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
